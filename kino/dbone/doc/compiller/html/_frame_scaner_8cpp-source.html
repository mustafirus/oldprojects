<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>compiler: P:/dbone/compiler/FrameScaner.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">P:</a>&nbsp;/&nbsp;<a class="el" href="dir_000001.html">dbone</a>&nbsp;/&nbsp;<a class="el" href="dir_000002.html">compiler</a></div>
<h1>FrameScaner.cpp</h1><a href="_frame_scaner_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="preprocessor">#line 2 "FrameScaner.cpp"</span>
00002 <span class="preprocessor"></span><span class="comment">/* A lexical scanner generated by flex */</span>
00003 
00004 <span class="comment">/* Scanner skeleton version:</span>
00005 <span class="comment"> * $Header: /home/daffy/u0/vern/flex/RCS/flex.skl,v 2.91 96/09/10 16:58:48 vern Exp $</span>
00006 <span class="comment"> */</span>
00007 
<a name="l00008"></a><a class="code" href="_frame_scaner_8cpp.html#a0">00008</a> <span class="preprocessor">#define FLEX_SCANNER</span>
<a name="l00009"></a><a class="code" href="_frame_scaner_8cpp.html#a1">00009</a> <span class="preprocessor"></span><span class="preprocessor">#define YY_FLEX_MAJOR_VERSION 2</span>
<a name="l00010"></a><a class="code" href="_frame_scaner_8cpp.html#a2">00010</a> <span class="preprocessor"></span><span class="preprocessor">#define YY_FLEX_MINOR_VERSION 5</span>
00011 <span class="preprocessor"></span>
00012 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00013 
00014 
00015 <span class="comment">/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */</span>
00016 <span class="preprocessor">#ifdef c_plusplus</span>
00017 <span class="preprocessor"></span><span class="preprocessor">#ifndef __cplusplus</span>
00018 <span class="preprocessor"></span><span class="preprocessor">#define __cplusplus</span>
00019 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00020 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00021 <span class="preprocessor"></span>
00022 
00023 <span class="preprocessor">#ifdef __cplusplus</span>
00024 <span class="preprocessor"></span>
00025 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00026 <span class="preprocessor">#include &lt;unistd.h&gt;</span>
00027 
00028 <span class="comment">/* Use prototypes in function declarations. */</span>
00029 <span class="preprocessor">#define YY_USE_PROTOS</span>
00030 <span class="preprocessor"></span>
00031 <span class="comment">/* The "const" storage-class-modifier is valid. */</span>
00032 <span class="preprocessor">#define YY_USE_CONST</span>
00033 <span class="preprocessor"></span>
00034 <span class="preprocessor">#else   </span><span class="comment">/* ! __cplusplus */</span>
00035 
00036 <span class="preprocessor">#if __STDC__</span>
00037 <span class="preprocessor"></span>
00038 <span class="preprocessor">#define YY_USE_PROTOS</span>
00039 <span class="preprocessor"></span><span class="preprocessor">#define YY_USE_CONST</span>
00040 <span class="preprocessor"></span>
00041 <span class="preprocessor">#endif  </span><span class="comment">/* __STDC__ */</span>
00042 <span class="preprocessor">#endif  </span><span class="comment">/* ! __cplusplus */</span>
00043 
00044 <span class="preprocessor">#ifdef __TURBOC__</span>
00045 <span class="preprocessor"></span><span class="preprocessor"> #pragma warn -rch</span>
00046 <span class="preprocessor"></span><span class="preprocessor"> #pragma warn -use</span>
00047 <span class="preprocessor"></span><span class="preprocessor">#include &lt;io.h&gt;</span>
00048 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00049 <span class="preprocessor">#define YY_USE_CONST</span>
00050 <span class="preprocessor"></span><span class="preprocessor">#define YY_USE_PROTOS</span>
00051 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00052 <span class="preprocessor"></span>
00053 <span class="preprocessor">#ifdef YY_USE_CONST</span>
00054 <span class="preprocessor"></span><span class="preprocessor">#define yyconst const</span>
00055 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00056"></a><a class="code" href="_frame_scaner_8cpp.html#a3">00056</a> <span class="preprocessor"></span><span class="preprocessor">#define yyconst</span>
00057 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00058 <span class="preprocessor"></span>
00059 
00060 <span class="preprocessor">#ifdef YY_USE_PROTOS</span>
00061 <span class="preprocessor"></span><span class="preprocessor">#define YY_PROTO(proto) proto</span>
00062 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00063"></a><a class="code" href="_frame_scaner_8cpp.html#a4">00063</a> <span class="preprocessor"></span><span class="preprocessor">#define YY_PROTO(proto) ()</span>
00064 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00065 <span class="preprocessor"></span>
00066 <span class="comment">/* Returned upon end-of-file. */</span>
<a name="l00067"></a><a class="code" href="_frame_scaner_8cpp.html#a5">00067</a> <span class="preprocessor">#define YY_NULL 0</span>
00068 <span class="preprocessor"></span>
00069 <span class="comment">/* Promotes a possibly negative, possibly signed char to an unsigned</span>
00070 <span class="comment"> * integer for use as an array index.  If the signed char is negative,</span>
00071 <span class="comment"> * we want to instead treat it as an 8-bit unsigned char, hence the</span>
00072 <span class="comment"> * double cast.</span>
00073 <span class="comment"> */</span>
<a name="l00074"></a><a class="code" href="_frame_scaner_8cpp.html#a6">00074</a> <span class="preprocessor">#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)</span>
00075 <span class="preprocessor"></span>
00076 <span class="comment">/* Enter a start condition.  This macro really ought to take a parameter,</span>
00077 <span class="comment"> * but we do it the disgusting crufty way forced on us by the ()-less</span>
00078 <span class="comment"> * definition of BEGIN.</span>
00079 <span class="comment"> */</span>
<a name="l00080"></a><a class="code" href="_frame_scaner_8cpp.html#a7">00080</a> <span class="preprocessor">#define BEGIN yy_start = 1 + 2 *</span>
00081 <span class="preprocessor"></span>
00082 <span class="comment">/* Translate the current start state into a value that can be later handed</span>
00083 <span class="comment"> * to BEGIN to return to the state.  The YYSTATE alias is for lex</span>
00084 <span class="comment"> * compatibility.</span>
00085 <span class="comment"> */</span>
<a name="l00086"></a><a class="code" href="_frame_scaner_8cpp.html#a8">00086</a> <span class="preprocessor">#define YY_START ((yy_start - 1) / 2)</span>
<a name="l00087"></a><a class="code" href="_frame_scaner_8cpp.html#a9">00087</a> <span class="preprocessor"></span><span class="preprocessor">#define YYSTATE YY_START</span>
00088 <span class="preprocessor"></span>
00089 <span class="comment">/* Action number for EOF rule of a given start state. */</span>
<a name="l00090"></a><a class="code" href="_frame_scaner_8cpp.html#a10">00090</a> <span class="preprocessor">#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)</span>
00091 <span class="preprocessor"></span>
00092 <span class="comment">/* Special action meaning "start processing a new file". */</span>
<a name="l00093"></a><a class="code" href="_frame_scaner_8cpp.html#a11">00093</a> <span class="preprocessor">#define YY_NEW_FILE yyrestart( yyin )</span>
00094 <span class="preprocessor"></span>
<a name="l00095"></a><a class="code" href="_frame_scaner_8cpp.html#a12">00095</a> <span class="preprocessor">#define YY_END_OF_BUFFER_CHAR 0</span>
00096 <span class="preprocessor"></span>
00097 <span class="comment">/* Size of default input buffer. */</span>
<a name="l00098"></a><a class="code" href="_frame_scaner_8cpp.html#a13">00098</a> <span class="preprocessor">#define YY_BUF_SIZE 16384</span>
00099 <span class="preprocessor"></span>
<a name="l00100"></a><a class="code" href="_frame_scaner_8cpp.html#a55">00100</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structyy__buffer__state.html">yy_buffer_state</a> *<a class="code" href="structyy__buffer__state.html">YY_BUFFER_STATE</a>;
00101 
00102 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="_dict_scaner_8cpp.html#a58">yyleng</a>;
00103 <span class="keyword">extern</span> FILE *<a class="code" href="_dict_scaner_8cpp.html#a59">yyin</a>, *<a class="code" href="_dict_scaner_8cpp.html#a60">yyout</a>;
00104 
<a name="l00105"></a><a class="code" href="_frame_scaner_8cpp.html#a14">00105</a> <span class="preprocessor">#define EOB_ACT_CONTINUE_SCAN 0</span>
<a name="l00106"></a><a class="code" href="_frame_scaner_8cpp.html#a15">00106</a> <span class="preprocessor"></span><span class="preprocessor">#define EOB_ACT_END_OF_FILE 1</span>
<a name="l00107"></a><a class="code" href="_frame_scaner_8cpp.html#a16">00107</a> <span class="preprocessor"></span><span class="preprocessor">#define EOB_ACT_LAST_MATCH 2</span>
00108 <span class="preprocessor"></span>
00109 <span class="comment">/* The funky do-while in the following #define is used to turn the definition</span>
00110 <span class="comment"> * int a single C statement (which needs a semi-colon terminator).  This</span>
00111 <span class="comment"> * avoids problems with code like:</span>
00112 <span class="comment"> *</span>
00113 <span class="comment"> *      if ( condition_holds )</span>
00114 <span class="comment"> *              yyless( 5 );</span>
00115 <span class="comment"> *      else</span>
00116 <span class="comment"> *              do_something_else();</span>
00117 <span class="comment"> *</span>
00118 <span class="comment"> * Prior to using the do-while the compiler would get upset at the</span>
00119 <span class="comment"> * "else" because it interpreted the "if" statement as being all</span>
00120 <span class="comment"> * done when it reached the ';' after the yyless() call.</span>
00121 <span class="comment"> */</span>
00122 
00123 <span class="comment">/* Return all but the first 'n' matched characters back to the input stream. */</span>
00124 
<a name="l00125"></a><a class="code" href="_frame_scaner_8cpp.html#a54">00125</a> <span class="preprocessor">#define yyless(n) \</span>
00126 <span class="preprocessor">        do \</span>
00127 <span class="preprocessor">                { \</span>
00128 <span class="preprocessor">                </span><span class="comment">/* Undo effects of setting up yytext. */</span> \
00129                 *yy_cp = yy_hold_char; \
00130                 YY_RESTORE_YY_MORE_OFFSET \
00131                 yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \
00132                 YY_DO_BEFORE_ACTION; <span class="comment">/* set up yytext again */</span> \
00133                 } \
00134         while ( 0 )
00135 
<a name="l00136"></a><a class="code" href="_frame_scaner_8cpp.html#a18">00136</a> <span class="preprocessor">#define unput(c) yyunput( c, yytext_ptr )</span>
00137 <span class="preprocessor"></span>
00138 <span class="comment">/* The following is because we cannot portably get our hands on size_t</span>
00139 <span class="comment"> * (without autoconf's help, which isn't available because we want</span>
00140 <span class="comment"> * flex-generated scanners to compile on their own).</span>
00141 <span class="comment"> */</span>
<a name="l00142"></a><a class="code" href="_frame_scaner_8cpp.html#a59">00142</a> <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="_dict_scaner_8cpp.html#a61">yy_size_t</a>;
00143 
00144 
00145 <span class="keyword">struct </span><a class="code" href="structyy__buffer__state.html">yy_buffer_state</a>
00146         {
<a name="l00147"></a><a class="code" href="structyy__buffer__state.html#o10">00147</a>         FILE *<a class="code" href="structyy__buffer__state.html#o0">yy_input_file</a>;
00148 
<a name="l00149"></a><a class="code" href="structyy__buffer__state.html#o11">00149</a>         <span class="keywordtype">char</span> *<a class="code" href="structyy__buffer__state.html#o1">yy_ch_buf</a>;                <span class="comment">/* input buffer */</span>
<a name="l00150"></a><a class="code" href="structyy__buffer__state.html#o12">00150</a>         <span class="keywordtype">char</span> *<a class="code" href="structyy__buffer__state.html#o2">yy_buf_pos</a>;               <span class="comment">/* current position in input buffer */</span>
00151 
00152         <span class="comment">/* Size of input buffer in bytes, not including room for EOB</span>
00153 <span class="comment">         * characters.</span>
00154 <span class="comment">         */</span>
<a name="l00155"></a><a class="code" href="structyy__buffer__state.html#o3">00155</a>         <a class="code" href="_dict_scaner_8cpp.html#a61">yy_size_t</a> <a class="code" href="structyy__buffer__state.html#o3">yy_buf_size</a>;
00156 
00157         <span class="comment">/* Number of characters read into yy_ch_buf, not including EOB</span>
00158 <span class="comment">         * characters.</span>
00159 <span class="comment">         */</span>
<a name="l00160"></a><a class="code" href="structyy__buffer__state.html#o4">00160</a>         <span class="keywordtype">int</span> <a class="code" href="structyy__buffer__state.html#o4">yy_n_chars</a>;
00161 
00162         <span class="comment">/* Whether we "own" the buffer - i.e., we know we created it,</span>
00163 <span class="comment">         * and can realloc() it to grow it, and should free() it to</span>
00164 <span class="comment">         * delete it.</span>
00165 <span class="comment">         */</span>
<a name="l00166"></a><a class="code" href="structyy__buffer__state.html#o5">00166</a>         <span class="keywordtype">int</span> <a class="code" href="structyy__buffer__state.html#o5">yy_is_our_buffer</a>;
00167 
00168         <span class="comment">/* Whether this is an "interactive" input source; if so, and</span>
00169 <span class="comment">         * if we're using stdio for input, then we want to use getc()</span>
00170 <span class="comment">         * instead of fread(), to make sure we stop fetching input after</span>
00171 <span class="comment">         * each newline.</span>
00172 <span class="comment">         */</span>
<a name="l00173"></a><a class="code" href="structyy__buffer__state.html#o6">00173</a>         <span class="keywordtype">int</span> <a class="code" href="structyy__buffer__state.html#o6">yy_is_interactive</a>;
00174 
00175         <span class="comment">/* Whether we're considered to be at the beginning of a line.</span>
00176 <span class="comment">         * If so, '^' rules will be active on the next match, otherwise</span>
00177 <span class="comment">         * not.</span>
00178 <span class="comment">         */</span>
<a name="l00179"></a><a class="code" href="structyy__buffer__state.html#o7">00179</a>         <span class="keywordtype">int</span> <a class="code" href="structyy__buffer__state.html#o7">yy_at_bol</a>;
00180 
00181         <span class="comment">/* Whether to try to fill the input buffer when we reach the</span>
00182 <span class="comment">         * end of it.</span>
00183 <span class="comment">         */</span>
<a name="l00184"></a><a class="code" href="structyy__buffer__state.html#o8">00184</a>         <span class="keywordtype">int</span> <a class="code" href="structyy__buffer__state.html#o8">yy_fill_buffer</a>;
00185 
<a name="l00186"></a><a class="code" href="structyy__buffer__state.html#o9">00186</a>         <span class="keywordtype">int</span> <a class="code" href="structyy__buffer__state.html#o9">yy_buffer_status</a>;
<a name="l00187"></a><a class="code" href="_frame_scaner_8cpp.html#a19">00187</a> <span class="preprocessor">#define YY_BUFFER_NEW 0</span>
<a name="l00188"></a><a class="code" href="_frame_scaner_8cpp.html#a20">00188</a> <span class="preprocessor"></span><span class="preprocessor">#define YY_BUFFER_NORMAL 1</span>
00189 <span class="preprocessor"></span>        <span class="comment">/* When an EOF's been seen but there's still some text to process</span>
00190 <span class="comment">         * then we mark the buffer as YY_EOF_PENDING, to indicate that we</span>
00191 <span class="comment">         * shouldn't try reading from the input source any more.  We might</span>
00192 <span class="comment">         * still have a bunch of tokens to match, though, because of</span>
00193 <span class="comment">         * possible backing-up.</span>
00194 <span class="comment">         *</span>
00195 <span class="comment">         * When we actually see the EOF, we change the status to "new"</span>
00196 <span class="comment">         * (via yyrestart()), so that the user can continue scanning by</span>
00197 <span class="comment">         * just pointing yyin at a new input file.</span>
00198 <span class="comment">         */</span>
<a name="l00199"></a><a class="code" href="_frame_scaner_8cpp.html#a21">00199</a> <span class="preprocessor">#define YY_BUFFER_EOF_PENDING 2</span>
00200 <span class="preprocessor"></span>        };
00201 
<a name="l00202"></a><a class="code" href="_frame_scaner_8cpp.html#a60">00202</a> <span class="keyword">static</span> <a class="code" href="_dict_scaner_8cpp.html#a57">YY_BUFFER_STATE</a> <a class="code" href="_frame_scaner_8cpp.html#a60">yy_current_buffer</a> = 0;
00203 
00204 <span class="comment">/* We provide macros for accessing buffer states in case in the</span>
00205 <span class="comment"> * future we want to put the buffer states in a more general</span>
00206 <span class="comment"> * "scanner state".</span>
00207 <span class="comment"> */</span>
<a name="l00208"></a><a class="code" href="_frame_scaner_8cpp.html#a22">00208</a> <span class="preprocessor">#define YY_CURRENT_BUFFER yy_current_buffer</span>
00209 <span class="preprocessor"></span>
00210 
00211 <span class="comment">/* yy_hold_char holds the character lost when yytext is formed. */</span>
<a name="l00212"></a><a class="code" href="_frame_scaner_8cpp.html#a61">00212</a> <span class="keyword">static</span> <span class="keywordtype">char</span> <a class="code" href="_frame_scaner_8cpp.html#a61">yy_hold_char</a>;
00213 
<a name="l00214"></a><a class="code" href="_frame_scaner_8cpp.html#a62">00214</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="_frame_scaner_8cpp.html#a62">yy_n_chars</a>;          <span class="comment">/* number of characters read into yy_ch_buf */</span>
00215 
00216 
<a name="l00217"></a><a class="code" href="_frame_scaner_8cpp.html#a56">00217</a> <span class="keywordtype">int</span> <a class="code" href="_dict_scaner_8cpp.html#a58">yyleng</a>;
00218 
00219 <span class="comment">/* Points to current character in buffer. */</span>
<a name="l00220"></a><a class="code" href="_frame_scaner_8cpp.html#a63">00220</a> <span class="keyword">static</span> <span class="keywordtype">char</span> *<a class="code" href="_frame_scaner_8cpp.html#a63">yy_c_buf_p</a> = (<span class="keywordtype">char</span> *) 0;
<a name="l00221"></a><a class="code" href="_frame_scaner_8cpp.html#a64">00221</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="_frame_scaner_8cpp.html#a64">yy_init</a> = 1;         <span class="comment">/* whether we need to initialize */</span>
<a name="l00222"></a><a class="code" href="_frame_scaner_8cpp.html#a65">00222</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="_frame_scaner_8cpp.html#a65">yy_start</a> = 0;        <span class="comment">/* start state number */</span>
00223 
00224 <span class="comment">/* Flag which is used to allow yywrap()'s to do buffer switches</span>
00225 <span class="comment"> * instead of setting up a fresh yyin.  A bit of a hack ...</span>
00226 <span class="comment"> */</span>
<a name="l00227"></a><a class="code" href="_frame_scaner_8cpp.html#a66">00227</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="_frame_scaner_8cpp.html#a66">yy_did_buffer_switch_on_eof</a>;
00228 
00229 <span class="keywordtype">void</span> yyrestart <a class="code" href="_dict_scaner_8cpp.html#a4">YY_PROTO</a>(( FILE *input_file ));
00230 
00231 <span class="keywordtype">void</span> yy_switch_to_buffer <a class="code" href="_dict_scaner_8cpp.html#a4">YY_PROTO</a>(( YY_BUFFER_STATE new_buffer ));
00232 <span class="keywordtype">void</span> yy_load_buffer_state <a class="code" href="_dict_scaner_8cpp.html#a4">YY_PROTO</a>(( <span class="keywordtype">void</span> ));
00233 <a class="code" href="_dict_scaner_8cpp.html#a57">YY_BUFFER_STATE</a> yy_create_buffer <a class="code" href="_dict_scaner_8cpp.html#a4">YY_PROTO</a>(( FILE *file, <span class="keywordtype">int</span> size ));
00234 <span class="keywordtype">void</span> yy_delete_buffer <a class="code" href="_dict_scaner_8cpp.html#a4">YY_PROTO</a>(( YY_BUFFER_STATE b ));
00235 <span class="keywordtype">void</span> yy_init_buffer <a class="code" href="_dict_scaner_8cpp.html#a4">YY_PROTO</a>(( YY_BUFFER_STATE b, FILE *file ));
00236 <span class="keywordtype">void</span> yy_flush_buffer <a class="code" href="_dict_scaner_8cpp.html#a4">YY_PROTO</a>(( YY_BUFFER_STATE b ));
<a name="l00237"></a><a class="code" href="_frame_scaner_8cpp.html#a23">00237</a> <span class="preprocessor">#define YY_FLUSH_BUFFER yy_flush_buffer( yy_current_buffer )</span>
00238 <span class="preprocessor"></span>
00239 <a class="code" href="_dict_scaner_8cpp.html#a57">YY_BUFFER_STATE</a> yy_scan_buffer <a class="code" href="_dict_scaner_8cpp.html#a4">YY_PROTO</a>(( <span class="keywordtype">char</span> *base, yy_size_t size ));
00240 <a class="code" href="_dict_scaner_8cpp.html#a57">YY_BUFFER_STATE</a> yy_scan_string <a class="code" href="_dict_scaner_8cpp.html#a4">YY_PROTO</a>(( yyconst <span class="keywordtype">char</span> *yy_str ));
00241 <a class="code" href="_dict_scaner_8cpp.html#a57">YY_BUFFER_STATE</a> yy_scan_bytes <a class="code" href="_dict_scaner_8cpp.html#a4">YY_PROTO</a>(( yyconst <span class="keywordtype">char</span> *bytes, <span class="keywordtype">int</span> len ));
00242 
00243 <span class="keyword">static</span> <span class="keywordtype">void</span> *yy_flex_alloc <a class="code" href="_dict_scaner_8cpp.html#a4">YY_PROTO</a>(( yy_size_t ));
00244 <span class="keyword">static</span> <span class="keywordtype">void</span> *yy_flex_realloc <a class="code" href="_dict_scaner_8cpp.html#a4">YY_PROTO</a>(( <span class="keywordtype">void</span> *, yy_size_t ));
00245 <span class="keyword">static</span> <span class="keywordtype">void</span> yy_flex_free <a class="code" href="_dict_scaner_8cpp.html#a4">YY_PROTO</a>(( <span class="keywordtype">void</span> * ));
00246 
<a name="l00247"></a><a class="code" href="_frame_scaner_8cpp.html#a24">00247</a> <span class="preprocessor">#define yy_new_buffer yy_create_buffer</span>
00248 <span class="preprocessor"></span>
<a name="l00249"></a><a class="code" href="_frame_scaner_8cpp.html#a25">00249</a> <span class="preprocessor">#define yy_set_interactive(is_interactive) \</span>
00250 <span class="preprocessor">        { \</span>
00251 <span class="preprocessor">        if ( ! yy_current_buffer ) \</span>
00252 <span class="preprocessor">                yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \</span>
00253 <span class="preprocessor">        yy_current_buffer-&gt;yy_is_interactive = is_interactive; \</span>
00254 <span class="preprocessor">        }</span>
00255 <span class="preprocessor"></span>
<a name="l00256"></a><a class="code" href="_frame_scaner_8cpp.html#a26">00256</a> <span class="preprocessor">#define yy_set_bol(at_bol) \</span>
00257 <span class="preprocessor">        { \</span>
00258 <span class="preprocessor">        if ( ! yy_current_buffer ) \</span>
00259 <span class="preprocessor">                yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \</span>
00260 <span class="preprocessor">        yy_current_buffer-&gt;yy_at_bol = at_bol; \</span>
00261 <span class="preprocessor">        }</span>
00262 <span class="preprocessor"></span>
<a name="l00263"></a><a class="code" href="_frame_scaner_8cpp.html#a27">00263</a> <span class="preprocessor">#define YY_AT_BOL() (yy_current_buffer-&gt;yy_at_bol)</span>
00264 <span class="preprocessor"></span>
00265 
<a name="l00266"></a><a class="code" href="_frame_scaner_8cpp.html#a28">00266</a> <span class="preprocessor">#define yywrap() 1</span>
<a name="l00267"></a><a class="code" href="_frame_scaner_8cpp.html#a29">00267</a> <span class="preprocessor"></span><span class="preprocessor">#define YY_SKIP_YYWRAP</span>
<a name="l00268"></a><a class="code" href="_frame_scaner_8cpp.html#a67">00268</a> <span class="preprocessor"></span><span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> <a class="code" href="_dict_scaner_8cpp.html#a69">YY_CHAR</a>;
<a name="l00269"></a><a class="code" href="_frame_scaner_8cpp.html#a58">00269</a> FILE *<a class="code" href="_dict_scaner_8cpp.html#a59">yyin</a> = (FILE *) 0, *<a class="code" href="_dict_scaner_8cpp.html#a60">yyout</a> = (FILE *) 0;
<a name="l00270"></a><a class="code" href="_frame_scaner_8cpp.html#a68">00270</a> <span class="keyword">typedef</span> <span class="keywordtype">int</span> <a class="code" href="_dict_scaner_8cpp.html#a70">yy_state_type</a>;
00271 <span class="keyword">extern</span> <span class="keywordtype">char</span> *<a class="code" href="_dict_scaner_8cpp.html#a71">yytext</a>;
<a name="l00272"></a><a class="code" href="_frame_scaner_8cpp.html#a30">00272</a> <span class="preprocessor">#define yytext_ptr yytext</span>
00273 <span class="preprocessor"></span>
00274 <span class="keyword">static</span> <a class="code" href="_dict_scaner_8cpp.html#a70">yy_state_type</a> yy_get_previous_state <a class="code" href="_dict_scaner_8cpp.html#a4">YY_PROTO</a>(( <span class="keywordtype">void</span> ));
00275 <span class="keyword">static</span> <a class="code" href="_dict_scaner_8cpp.html#a70">yy_state_type</a> yy_try_NUL_trans <a class="code" href="_dict_scaner_8cpp.html#a4">YY_PROTO</a>(( yy_state_type current_state ));
00276 <span class="keyword">static</span> <span class="keywordtype">int</span> yy_get_next_buffer <a class="code" href="_dict_scaner_8cpp.html#a4">YY_PROTO</a>(( <span class="keywordtype">void</span> ));
00277 <span class="keyword">static</span> <span class="keywordtype">void</span> yy_fatal_error <a class="code" href="_dict_scaner_8cpp.html#a4">YY_PROTO</a>(( yyconst <span class="keywordtype">char</span> msg[] ));
00278 
00279 <span class="comment">/* Done after the current pattern has been matched and before the</span>
00280 <span class="comment"> * corresponding action - sets up yytext.</span>
00281 <span class="comment"> */</span>
<a name="l00282"></a><a class="code" href="_frame_scaner_8cpp.html#a31">00282</a> <span class="preprocessor">#define YY_DO_BEFORE_ACTION \</span>
00283 <span class="preprocessor">        yytext_ptr = yy_bp; \</span>
00284 <span class="preprocessor">        yyleng = (int) (yy_cp - yy_bp); \</span>
00285 <span class="preprocessor">        yy_hold_char = *yy_cp; \</span>
00286 <span class="preprocessor">        *yy_cp = '\0'; \</span>
00287 <span class="preprocessor">        yy_c_buf_p = yy_cp;</span>
00288 <span class="preprocessor"></span>
<a name="l00289"></a><a class="code" href="_frame_scaner_8cpp.html#a32">00289</a> <span class="preprocessor">#define YY_NUM_RULES 6</span>
<a name="l00290"></a><a class="code" href="_frame_scaner_8cpp.html#a33">00290</a> <span class="preprocessor"></span><span class="preprocessor">#define YY_END_OF_BUFFER 7</span>
<a name="l00291"></a><a class="code" href="_frame_scaner_8cpp.html#a70">00291</a> <span class="preprocessor"></span><span class="keyword">static</span> <a class="code" href="_dict_scaner_8cpp.html#a3">yyconst</a> <span class="keywordtype">short</span> <span class="keywordtype">int</span> <a class="code" href="_frame_scaner_8cpp.html#a70">yy_accept</a>[14] =
00292     {   0,
00293         0,    0,    7,    6,    3,    1,    2,    4,    0,    5,
00294         5,    5,    0
00295     } ;
00296 
<a name="l00297"></a><a class="code" href="_frame_scaner_8cpp.html#a71">00297</a> <span class="keyword">static</span> <a class="code" href="_dict_scaner_8cpp.html#a3">yyconst</a> <span class="keywordtype">int</span> <a class="code" href="_frame_scaner_8cpp.html#a71">yy_ec</a>[256] =
00298     {   0,
00299         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
00300         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
00301         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
00302         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
00303         1,    1,    1,    2,    1,    3,    1,    4,    4,    4,
00304         4,    4,    4,    4,    4,    4,    4,    1,    1,    5,
00305         1,    6,    1,    1,    7,    7,    7,    7,    7,    7,
00306         7,    7,    7,    7,    7,    7,    7,    7,    7,    7,
00307         7,    7,    7,    7,    7,    7,    7,    7,    7,    7,
00308         1,    1,    1,    1,    1,    1,    7,    7,    7,    7,
00309 
00310         7,    7,    7,    7,    7,    7,    7,    7,    7,    7,
00311         7,    7,    7,    7,    7,    7,    7,    7,    7,    7,
00312         7,    7,    1,    1,    1,    1,    1,    1,    1,    1,
00313         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
00314         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
00315         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
00316         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
00317         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
00318         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
00319         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
00320 
00321         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
00322         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
00323         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
00324         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
00325         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
00326         1,    1,    1,    1,    1
00327     } ;
00328 
<a name="l00329"></a><a class="code" href="_frame_scaner_8cpp.html#a72">00329</a> <span class="keyword">static</span> <a class="code" href="_dict_scaner_8cpp.html#a3">yyconst</a> <span class="keywordtype">int</span> <a class="code" href="_frame_scaner_8cpp.html#a72">yy_meta</a>[8] =
00330     {   0,
00331         1,    1,    2,    2,    1,    1,    2
00332     } ;
00333 
<a name="l00334"></a><a class="code" href="_frame_scaner_8cpp.html#a73">00334</a> <span class="keyword">static</span> <a class="code" href="_dict_scaner_8cpp.html#a3">yyconst</a> <span class="keywordtype">short</span> <span class="keywordtype">int</span> <a class="code" href="_frame_scaner_8cpp.html#a73">yy_base</a>[16] =
00335     {   0,
00336         0,    0,   15,   16,   16,   16,   16,   11,    6,    9,
00337         8,    7,   16,    7,    6
00338     } ;
00339 
<a name="l00340"></a><a class="code" href="_frame_scaner_8cpp.html#a74">00340</a> <span class="keyword">static</span> <a class="code" href="_dict_scaner_8cpp.html#a3">yyconst</a> <span class="keywordtype">short</span> <span class="keywordtype">int</span> <a class="code" href="_frame_scaner_8cpp.html#a74">yy_def</a>[16] =
00341     {   0,
00342        13,    1,   13,   13,   13,   13,   13,   14,   13,   14,
00343        15,   15,    0,   13,   13
00344     } ;
00345 
<a name="l00346"></a><a class="code" href="_frame_scaner_8cpp.html#a75">00346</a> <span class="keyword">static</span> <a class="code" href="_dict_scaner_8cpp.html#a3">yyconst</a> <span class="keywordtype">short</span> <span class="keywordtype">int</span> <a class="code" href="_frame_scaner_8cpp.html#a75">yy_nxt</a>[24] =
00347     {   0,
00348         4,    5,    4,    4,    6,    7,    8,   12,   10,    9,
00349         9,    9,   11,    9,   13,    3,   13,   13,   13,   13,
00350        13,   13,   13
00351     } ;
00352 
<a name="l00353"></a><a class="code" href="_frame_scaner_8cpp.html#a76">00353</a> <span class="keyword">static</span> <a class="code" href="_dict_scaner_8cpp.html#a3">yyconst</a> <span class="keywordtype">short</span> <span class="keywordtype">int</span> <a class="code" href="_frame_scaner_8cpp.html#a76">yy_chk</a>[24] =
00354     {   0,
00355         1,    1,    1,    1,    1,    1,    1,   15,   14,   12,
00356        11,   10,    9,    8,    3,   13,   13,   13,   13,   13,
00357        13,   13,   13
00358     } ;
00359 
<a name="l00360"></a><a class="code" href="_frame_scaner_8cpp.html#a77">00360</a> <span class="keyword">static</span> <a class="code" href="_dict_scaner_8cpp.html#a70">yy_state_type</a> <a class="code" href="_frame_scaner_8cpp.html#a77">yy_last_accepting_state</a>;
<a name="l00361"></a><a class="code" href="_frame_scaner_8cpp.html#a78">00361</a> <span class="keyword">static</span> <span class="keywordtype">char</span> *<a class="code" href="_frame_scaner_8cpp.html#a78">yy_last_accepting_cpos</a>;
00362 
00363 <span class="comment">/* The intent behind this definition is that it'll catch</span>
00364 <span class="comment"> * any uses of REJECT which flex missed.</span>
00365 <span class="comment"> */</span>
<a name="l00366"></a><a class="code" href="_frame_scaner_8cpp.html#a34">00366</a> <span class="preprocessor">#define REJECT reject_used_but_not_detected</span>
<a name="l00367"></a><a class="code" href="_frame_scaner_8cpp.html#a35">00367</a> <span class="preprocessor"></span><span class="preprocessor">#define yymore() yymore_used_but_not_detected</span>
<a name="l00368"></a><a class="code" href="_frame_scaner_8cpp.html#a36">00368</a> <span class="preprocessor"></span><span class="preprocessor">#define YY_MORE_ADJ 0</span>
<a name="l00369"></a><a class="code" href="_frame_scaner_8cpp.html#a37">00369</a> <span class="preprocessor"></span><span class="preprocessor">#define YY_RESTORE_YY_MORE_OFFSET</span>
<a name="l00370"></a><a class="code" href="_frame_scaner_8cpp.html#a69">00370</a> <span class="preprocessor"></span><span class="keywordtype">char</span> *<a class="code" href="_dict_scaner_8cpp.html#a71">yytext</a>;
00371 <span class="preprocessor">#line 1 "FrameScaner.l"</span>
<a name="l00372"></a><a class="code" href="_frame_scaner_8cpp.html#a38">00372</a> <span class="preprocessor"></span><span class="preprocessor">#define INITIAL 0</span>
00373 <span class="preprocessor"></span><span class="preprocessor">#line 2 "FrameScaner.l"</span>
00374 <span class="preprocessor"></span><span class="preprocessor">#include "<a class="code" href="stdafx_8h.html">stdafx.h</a>"</span>
00375 
<a name="l00376"></a><a class="code" href="_frame_scaner_8cpp.html#a79">00376</a> <span class="keyword">typedef</span> string <a class="code" href="_dict_parser_8cpp.html#a57">YYSTYPE</a>;
<a name="l00377"></a><a class="code" href="_frame_scaner_8cpp.html#a39">00377</a> <span class="preprocessor">#define YYSTYPE_IS_DECLARED 1</span>
00378 <span class="preprocessor"></span><span class="preprocessor">#include "<a class="code" href="_frame_parser_8hpp.html">FrameParser.hpp</a>"</span>
<a name="l00379"></a><a class="code" href="_frame_scaner_8cpp.html#a40">00379</a> <span class="preprocessor">#define YY_NEVER_INTERACTIVE 1</span>
00380 <span class="preprocessor"></span><span class="preprocessor">#line 381 "FrameScaner.cpp"</span>
00381 <span class="preprocessor"></span>
00382 <span class="comment">/* Macros after this point can all be overridden by user definitions in</span>
00383 <span class="comment"> * section 1.</span>
00384 <span class="comment"> */</span>
00385 
00386 <span class="preprocessor">#ifndef YY_SKIP_YYWRAP</span>
00387 <span class="preprocessor"></span><span class="preprocessor">#ifdef __cplusplus</span>
00388 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">"C"</span> <span class="keywordtype">int</span> <a class="code" href="_dict_scaner_8cpp.html#a28">yywrap</a> <a class="code" href="_dict_scaner_8cpp.html#a4">YY_PROTO</a>(( <span class="keywordtype">void</span> ));
00389 <span class="preprocessor">#else</span>
00390 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="_dict_scaner_8cpp.html#a28">yywrap</a> <a class="code" href="_dict_scaner_8cpp.html#a4">YY_PROTO</a>(( <span class="keywordtype">void</span> ));
00391 <span class="preprocessor">#endif</span>
00392 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00393 <span class="preprocessor"></span>
00394 <span class="preprocessor">#ifndef YY_NO_UNPUT</span>
00395 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> yyunput <a class="code" href="_dict_scaner_8cpp.html#a4">YY_PROTO</a>(( <span class="keywordtype">int</span> c, <span class="keywordtype">char</span> *buf_ptr ));
00396 <span class="preprocessor">#endif</span>
00397 <span class="preprocessor"></span>
00398 <span class="preprocessor">#ifndef yytext_ptr</span>
00399 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> yy_flex_strncpy <a class="code" href="_dict_scaner_8cpp.html#a4">YY_PROTO</a>(( <span class="keywordtype">char</span> *, yyconst <span class="keywordtype">char</span> *, <span class="keywordtype">int</span> ));
00400 <span class="preprocessor">#endif</span>
00401 <span class="preprocessor"></span>
00402 <span class="preprocessor">#ifdef YY_NEED_STRLEN</span>
00403 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> yy_flex_strlen <a class="code" href="_dict_scaner_8cpp.html#a4">YY_PROTO</a>(( yyconst <span class="keywordtype">char</span> * ));
00404 <span class="preprocessor">#endif</span>
00405 <span class="preprocessor"></span>
00406 <span class="preprocessor">#ifndef YY_NO_INPUT</span>
00407 <span class="preprocessor"></span><span class="preprocessor">#ifdef __cplusplus</span>
00408 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> yyinput <a class="code" href="_dict_scaner_8cpp.html#a4">YY_PROTO</a>(( <span class="keywordtype">void</span> ));
00409 <span class="preprocessor">#else</span>
00410 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> input <a class="code" href="_dict_scaner_8cpp.html#a4">YY_PROTO</a>(( <span class="keywordtype">void</span> ));
00411 <span class="preprocessor">#endif</span>
00412 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00413 <span class="preprocessor"></span>
00414 <span class="preprocessor">#if YY_STACK_USED</span>
00415 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> yy_start_stack_ptr = 0;
00416 <span class="keyword">static</span> <span class="keywordtype">int</span> yy_start_stack_depth = 0;
00417 <span class="keyword">static</span> <span class="keywordtype">int</span> *yy_start_stack = 0;
00418 <span class="preprocessor">#ifndef YY_NO_PUSH_STATE</span>
00419 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> yy_push_state <a class="code" href="_dict_scaner_8cpp.html#a4">YY_PROTO</a>(( <span class="keywordtype">int</span> new_state ));
00420 <span class="preprocessor">#endif</span>
00421 <span class="preprocessor"></span><span class="preprocessor">#ifndef YY_NO_POP_STATE</span>
00422 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> yy_pop_state <a class="code" href="_dict_scaner_8cpp.html#a4">YY_PROTO</a>(( <span class="keywordtype">void</span> ));
00423 <span class="preprocessor">#endif</span>
00424 <span class="preprocessor"></span><span class="preprocessor">#ifndef YY_NO_TOP_STATE</span>
00425 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> yy_top_state <a class="code" href="_dict_scaner_8cpp.html#a4">YY_PROTO</a>(( <span class="keywordtype">void</span> ));
00426 <span class="preprocessor">#endif</span>
00427 <span class="preprocessor"></span>
00428 <span class="preprocessor">#else</span>
<a name="l00429"></a><a class="code" href="_frame_scaner_8cpp.html#a41">00429</a> <span class="preprocessor"></span><span class="preprocessor">#define YY_NO_PUSH_STATE 1</span>
<a name="l00430"></a><a class="code" href="_frame_scaner_8cpp.html#a42">00430</a> <span class="preprocessor"></span><span class="preprocessor">#define YY_NO_POP_STATE 1</span>
<a name="l00431"></a><a class="code" href="_frame_scaner_8cpp.html#a43">00431</a> <span class="preprocessor"></span><span class="preprocessor">#define YY_NO_TOP_STATE 1</span>
00432 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00433 <span class="preprocessor"></span>
00434 <span class="preprocessor">#ifdef YY_MALLOC_DECL</span>
00435 <span class="preprocessor"></span>YY_MALLOC_DECL
00436 <span class="preprocessor">#else</span>
00437 <span class="preprocessor"></span><span class="preprocessor">#if __STDC__</span>
00438 <span class="preprocessor"></span><span class="preprocessor">#ifndef __cplusplus</span>
00439 <span class="preprocessor"></span><span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00440 <span class="preprocessor">#endif</span>
00441 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00442 <span class="preprocessor"></span><span class="comment">/* Just try to get by without declaring the routines.  This will fail</span>
00443 <span class="comment"> * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)</span>
00444 <span class="comment"> * or sizeof(void*) != sizeof(int).</span>
00445 <span class="comment"> */</span>
00446 <span class="preprocessor">#endif</span>
00447 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00448 <span class="preprocessor"></span>
00449 <span class="comment">/* Amount of stuff to slurp up with each read. */</span>
00450 <span class="preprocessor">#ifndef YY_READ_BUF_SIZE</span>
<a name="l00451"></a><a class="code" href="_frame_scaner_8cpp.html#a44">00451</a> <span class="preprocessor"></span><span class="preprocessor">#define YY_READ_BUF_SIZE 8192</span>
00452 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00453 <span class="preprocessor"></span>
00454 <span class="comment">/* Copy whatever the last rule matched to the standard output. */</span>
00455 
00456 <span class="preprocessor">#ifndef ECHO</span>
00457 <span class="preprocessor"></span><span class="comment">/* This used to be an fputs(), but since the string might contain NUL's,</span>
00458 <span class="comment"> * we now use fwrite().</span>
00459 <span class="comment"> */</span>
<a name="l00460"></a><a class="code" href="_frame_scaner_8cpp.html#a45">00460</a> <span class="preprocessor">#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )</span>
00461 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00462 <span class="preprocessor"></span>
00463 <span class="comment">/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,</span>
00464 <span class="comment"> * is returned in "result".</span>
00465 <span class="comment"> */</span>
00466 <span class="preprocessor">#ifndef YY_INPUT</span>
<a name="l00467"></a><a class="code" href="_frame_scaner_8cpp.html#a46">00467</a> <span class="preprocessor"></span><span class="preprocessor">#define YY_INPUT(buf,result,max_size) \</span>
00468 <span class="preprocessor">        if ( yy_current_buffer-&gt;yy_is_interactive ) \</span>
00469 <span class="preprocessor">                { \</span>
00470 <span class="preprocessor">                int c = '*', n; \</span>
00471 <span class="preprocessor">                for ( n = 0; n &lt; max_size &amp;&amp; \</span>
00472 <span class="preprocessor">                             (c = getc( yyin )) != EOF &amp;&amp; c != '\n'; ++n ) \</span>
00473 <span class="preprocessor">                        buf[n] = (char) c; \</span>
00474 <span class="preprocessor">                if ( c == '\n' ) \</span>
00475 <span class="preprocessor">                        buf[n++] = (char) c; \</span>
00476 <span class="preprocessor">                if ( c == EOF &amp;&amp; ferror( yyin ) ) \</span>
00477 <span class="preprocessor">                        YY_FATAL_ERROR( "input in flex scanner failed" ); \</span>
00478 <span class="preprocessor">                result = n; \</span>
00479 <span class="preprocessor">                } \</span>
00480 <span class="preprocessor">        else if ( ((result = fread( buf, 1, max_size, yyin )) == 0) \</span>
00481 <span class="preprocessor">                  &amp;&amp; ferror( yyin ) ) \</span>
00482 <span class="preprocessor">                YY_FATAL_ERROR( "input in flex scanner failed" );</span>
00483 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00484 <span class="preprocessor"></span>
00485 <span class="comment">/* No semi-colon after return; correct usage is to write "yyterminate();" -</span>
00486 <span class="comment"> * we don't want an extra ';' after the "return" because that will cause</span>
00487 <span class="comment"> * some compilers to complain about unreachable statements.</span>
00488 <span class="comment"> */</span>
00489 <span class="preprocessor">#ifndef yyterminate</span>
<a name="l00490"></a><a class="code" href="_frame_scaner_8cpp.html#a47">00490</a> <span class="preprocessor"></span><span class="preprocessor">#define yyterminate() return YY_NULL</span>
00491 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00492 <span class="preprocessor"></span>
00493 <span class="comment">/* Number of entries by which start-condition stack grows. */</span>
00494 <span class="preprocessor">#ifndef YY_START_STACK_INCR</span>
<a name="l00495"></a><a class="code" href="_frame_scaner_8cpp.html#a48">00495</a> <span class="preprocessor"></span><span class="preprocessor">#define YY_START_STACK_INCR 25</span>
00496 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00497 <span class="preprocessor"></span>
00498 <span class="comment">/* Report a fatal error. */</span>
00499 <span class="preprocessor">#ifndef YY_FATAL_ERROR</span>
<a name="l00500"></a><a class="code" href="_frame_scaner_8cpp.html#a49">00500</a> <span class="preprocessor"></span><span class="preprocessor">#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )</span>
00501 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00502 <span class="preprocessor"></span>
00503 <span class="comment">/* Default declaration of generated scanner - a define so the user can</span>
00504 <span class="comment"> * easily add parameters.</span>
00505 <span class="comment"> */</span>
00506 <span class="preprocessor">#ifndef YY_DECL</span>
<a name="l00507"></a><a class="code" href="_frame_scaner_8cpp.html#a50">00507</a> <span class="preprocessor"></span><span class="preprocessor">#define YY_DECL int yylex YY_PROTO(( void ))</span>
00508 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00509 <span class="preprocessor"></span>
00510 <span class="comment">/* Code executed at the beginning of each rule, after yytext and yyleng</span>
00511 <span class="comment"> * have been set up.</span>
00512 <span class="comment"> */</span>
00513 <span class="preprocessor">#ifndef YY_USER_ACTION</span>
00514 <span class="preprocessor"></span><span class="preprocessor">#define YY_USER_ACTION</span>
00515 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00516 <span class="preprocessor"></span>
00517 <span class="comment">/* Code executed at the end of each rule. */</span>
00518 <span class="preprocessor">#ifndef YY_BREAK</span>
<a name="l00519"></a><a class="code" href="_frame_scaner_8cpp.html#a51">00519</a> <span class="preprocessor"></span><span class="preprocessor">#define YY_BREAK break;</span>
00520 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00521 <span class="preprocessor"></span>
<a name="l00522"></a><a class="code" href="_frame_scaner_8cpp.html#a52">00522</a> <span class="preprocessor">#define YY_RULE_SETUP \</span>
00523 <span class="preprocessor">        YY_USER_ACTION</span>
00524 <span class="preprocessor"></span>
00525 <a class="code" href="_dict_scaner_8cpp.html#a52">YY_DECL</a>
00526         {
00527         <span class="keyword">register</span> <a class="code" href="_dict_scaner_8cpp.html#a70">yy_state_type</a> yy_current_state;
00528         <span class="keyword">register</span> <span class="keywordtype">char</span> *yy_cp, *<a class="code" href="_dict_scaner_8cpp.html#a82">yy_bp</a>;
00529         <span class="keyword">register</span> <span class="keywordtype">int</span> yy_act;
00530 
00531 <span class="preprocessor">#line 15 "FrameScaner.l"</span>
00532 <span class="preprocessor"></span>
00533 
00534 <span class="preprocessor">#line 535 "FrameScaner.cpp"</span>
00535 <span class="preprocessor"></span>
00536         <span class="keywordflow">if</span> ( <a class="code" href="_frame_scaner_8cpp.html#a64">yy_init</a> )
00537                 {
00538                 <a class="code" href="_frame_scaner_8cpp.html#a64">yy_init</a> = 0;
00539 
00540 <span class="preprocessor">#ifdef YY_USER_INIT</span>
00541 <span class="preprocessor"></span>                YY_USER_INIT;
00542 <span class="preprocessor">#endif</span>
00543 <span class="preprocessor"></span>
00544                 <span class="keywordflow">if</span> ( ! <a class="code" href="_frame_scaner_8cpp.html#a65">yy_start</a> )
00545                         <a class="code" href="_frame_scaner_8cpp.html#a65">yy_start</a> = 1;   <span class="comment">/* first start state */</span>
00546 
00547                 <span class="keywordflow">if</span> ( ! <a class="code" href="_dict_scaner_8cpp.html#a59">yyin</a> )
00548                         <a class="code" href="_dict_scaner_8cpp.html#a59">yyin</a> = stdin;
00549 
00550                 <span class="keywordflow">if</span> ( ! <a class="code" href="_dict_scaner_8cpp.html#a60">yyout</a> )
00551                         <a class="code" href="_dict_scaner_8cpp.html#a60">yyout</a> = stdout;
00552 
00553                 <span class="keywordflow">if</span> ( ! <a class="code" href="_frame_scaner_8cpp.html#a60">yy_current_buffer</a> )
00554                         <a class="code" href="_frame_scaner_8cpp.html#a60">yy_current_buffer</a> =
00555                                 yy_create_buffer( <a class="code" href="_dict_scaner_8cpp.html#a59">yyin</a>, <a class="code" href="_dict_scaner_8cpp.html#a13">YY_BUF_SIZE</a> );
00556 
00557                 yy_load_buffer_state();
00558                 }
00559 
00560         <span class="keywordflow">while</span> ( 1 )             <span class="comment">/* loops until end-of-file is reached */</span>
00561                 {
00562                 yy_cp = <a class="code" href="_frame_scaner_8cpp.html#a63">yy_c_buf_p</a>;
00563 
00564                 <span class="comment">/* Support of yytext. */</span>
00565                 *yy_cp = <a class="code" href="_frame_scaner_8cpp.html#a61">yy_hold_char</a>;
00566 
00567                 <span class="comment">/* yy_bp points to the position in yy_ch_buf of the start of</span>
00568 <span class="comment">                 * the current run.</span>
00569 <span class="comment">                 */</span>
00570                 <a class="code" href="_dict_scaner_8cpp.html#a82">yy_bp</a> = yy_cp;
00571 
00572                 yy_current_state = <a class="code" href="_frame_scaner_8cpp.html#a65">yy_start</a>;
00573 yy_match:
00574                 <span class="keywordflow">do</span>
00575                         {
00576                         <span class="keyword">register</span> <a class="code" href="_dict_scaner_8cpp.html#a69">YY_CHAR</a> yy_c = <a class="code" href="_frame_scaner_8cpp.html#a71">yy_ec</a>[<a class="code" href="_dict_scaner_8cpp.html#a6">YY_SC_TO_UI</a>(*yy_cp)];
00577                         <span class="keywordflow">if</span> ( <a class="code" href="_frame_scaner_8cpp.html#a70">yy_accept</a>[yy_current_state] )
00578                                 {
00579                                 <a class="code" href="_frame_scaner_8cpp.html#a77">yy_last_accepting_state</a> = yy_current_state;
00580                                 <a class="code" href="_frame_scaner_8cpp.html#a78">yy_last_accepting_cpos</a> = yy_cp;
00581                                 }
00582                         <span class="keywordflow">while</span> ( <a class="code" href="_frame_scaner_8cpp.html#a76">yy_chk</a>[<a class="code" href="_frame_scaner_8cpp.html#a73">yy_base</a>[yy_current_state] + yy_c] != yy_current_state )
00583                                 {
00584                                 yy_current_state = (int) <a class="code" href="_frame_scaner_8cpp.html#a74">yy_def</a>[yy_current_state];
00585                                 <span class="keywordflow">if</span> ( yy_current_state &gt;= 14 )
00586                                         yy_c = <a class="code" href="_frame_scaner_8cpp.html#a72">yy_meta</a>[(<span class="keywordtype">unsigned</span> int) yy_c];
00587                                 }
00588                         yy_current_state = <a class="code" href="_frame_scaner_8cpp.html#a75">yy_nxt</a>[<a class="code" href="_frame_scaner_8cpp.html#a73">yy_base</a>[yy_current_state] + (<span class="keywordtype">unsigned</span> int) yy_c];
00589                         ++yy_cp;
00590                         }
00591                 <span class="keywordflow">while</span> ( <a class="code" href="_frame_scaner_8cpp.html#a73">yy_base</a>[yy_current_state] != 16 );
00592 
00593 yy_find_action:
00594                 yy_act = <a class="code" href="_frame_scaner_8cpp.html#a70">yy_accept</a>[yy_current_state];
00595                 <span class="keywordflow">if</span> ( yy_act == 0 )
00596                         { <span class="comment">/* have to back up */</span>
00597                         yy_cp = <a class="code" href="_frame_scaner_8cpp.html#a78">yy_last_accepting_cpos</a>;
00598                         yy_current_state = <a class="code" href="_frame_scaner_8cpp.html#a77">yy_last_accepting_state</a>;
00599                         yy_act = <a class="code" href="_frame_scaner_8cpp.html#a70">yy_accept</a>[yy_current_state];
00600                         }
00601 
00602                 <a class="code" href="_dict_scaner_8cpp.html#a31">YY_DO_BEFORE_ACTION</a>;
00603 
00604 
00605 do_action:      <span class="comment">/* This label is used only to access EOF actions. */</span>
00606 
00607 
00608                 <span class="keywordflow">switch</span> ( yy_act )
00609         { <span class="comment">/* beginning of action switch */</span>
00610                         <span class="keywordflow">case</span> 0: <span class="comment">/* must back up */</span>
00611                         <span class="comment">/* undo the effects of YY_DO_BEFORE_ACTION */</span>
00612                         *yy_cp = <a class="code" href="_frame_scaner_8cpp.html#a61">yy_hold_char</a>;
00613                         yy_cp = <a class="code" href="_frame_scaner_8cpp.html#a78">yy_last_accepting_cpos</a>;
00614                         yy_current_state = <a class="code" href="_frame_scaner_8cpp.html#a77">yy_last_accepting_state</a>;
00615                         <span class="keywordflow">goto</span> yy_find_action;
00616 
00617 <span class="keywordflow">case</span> 1:
00618 <a class="code" href="_dict_scaner_8cpp.html#a54">YY_RULE_SETUP</a>
00619 <span class="preprocessor">#line 17 "FrameScaner.l"</span>
00620 <span class="preprocessor"></span><a class="code" href="_dict_parser_8cpp.html#a71">yylval</a> = <span class="stringliteral">""</span>; <span class="keywordflow">return</span> <span class="charliteral">'&lt;'</span>;
00621         <a class="code" href="_dict_scaner_8cpp.html#a53">YY_BREAK</a>
00622 <span class="keywordflow">case</span> 2:
00623 <a class="code" href="_dict_scaner_8cpp.html#a54">YY_RULE_SETUP</a>
00624 <span class="preprocessor">#line 18 "FrameScaner.l"</span>
00625 <span class="preprocessor"></span><a class="code" href="_dict_parser_8cpp.html#a71">yylval</a> = <span class="stringliteral">""</span>; <span class="keywordflow">return</span> <span class="charliteral">'&gt;'</span>;
00626         <a class="code" href="_dict_scaner_8cpp.html#a53">YY_BREAK</a>
00627 <span class="keywordflow">case</span> 3:
00628 <a class="code" href="_dict_scaner_8cpp.html#a54">YY_RULE_SETUP</a>
00629 <span class="preprocessor">#line 19 "FrameScaner.l"</span>
00630 <span class="preprocessor"></span><a class="code" href="_dict_parser_8cpp.html#a71">yylval</a> = <span class="stringliteral">""</span>; <span class="keywordflow">return</span> <span class="charliteral">','</span>;
00631         <a class="code" href="_dict_scaner_8cpp.html#a53">YY_BREAK</a>
00632 <span class="keywordflow">case</span> 4:
00633 <a class="code" href="_dict_scaner_8cpp.html#a54">YY_RULE_SETUP</a>
00634 <span class="preprocessor">#line 20 "FrameScaner.l"</span>
00635 <span class="preprocessor"></span><a class="code" href="_dict_parser_8cpp.html#a71">yylval</a> = <a class="code" href="_dict_scaner_8cpp.html#a71">yytext</a>; <span class="keywordflow">return</span> <a class="code" href="_frame_parser_8cpp.html#a4">FRAME_TYPE</a>;
00636         <a class="code" href="_dict_scaner_8cpp.html#a53">YY_BREAK</a>
00637 <span class="keywordflow">case</span> 5:
00638 <a class="code" href="_dict_scaner_8cpp.html#a54">YY_RULE_SETUP</a>
00639 <span class="preprocessor">#line 21 "FrameScaner.l"</span>
00640 <span class="preprocessor"></span><a class="code" href="_dict_parser_8cpp.html#a71">yylval</a> = <a class="code" href="_dict_scaner_8cpp.html#a71">yytext</a>; <span class="keywordflow">return</span> <a class="code" href="_frame_parser_8cpp.html#a5">FIELD_NAME</a>;
00641         <a class="code" href="_dict_scaner_8cpp.html#a53">YY_BREAK</a>
00642 <span class="keywordflow">case</span> 6:
00643 <a class="code" href="_dict_scaner_8cpp.html#a54">YY_RULE_SETUP</a>
00644 <span class="preprocessor">#line 23 "FrameScaner.l"</span>
00645 <span class="preprocessor"></span><a class="code" href="_dict_scaner_8cpp.html#a47">ECHO</a>;
00646         <a class="code" href="_dict_scaner_8cpp.html#a53">YY_BREAK</a>
00647 <span class="preprocessor">#line 648 "FrameScaner.cpp"</span>
00648 <span class="preprocessor"></span><span class="keywordflow">case</span> <a class="code" href="_dict_scaner_8cpp.html#a10">YY_STATE_EOF</a>(<a class="code" href="_dict_scaner_8cpp.html#a38">INITIAL</a>):
00649         <a class="code" href="_dict_scaner_8cpp.html#a49">yyterminate</a>();
00650 
00651         <span class="keywordflow">case</span> <a class="code" href="_dict_scaner_8cpp.html#a33">YY_END_OF_BUFFER</a>:
00652                 {
00653                 <span class="comment">/* Amount of text matched not including the EOB char. */</span>
00654                 <span class="keywordtype">int</span> yy_amount_of_matched_text = (int) (yy_cp - <a class="code" href="_dict_scaner_8cpp.html#a30">yytext_ptr</a>) - 1;
00655 
00656                 <span class="comment">/* Undo the effects of YY_DO_BEFORE_ACTION. */</span>
00657                 *yy_cp = <a class="code" href="_frame_scaner_8cpp.html#a61">yy_hold_char</a>;
00658                 <a class="code" href="_dict_scaner_8cpp.html#a37">YY_RESTORE_YY_MORE_OFFSET</a>
00659 
00660                 <span class="keywordflow">if</span> ( <a class="code" href="_frame_scaner_8cpp.html#a60">yy_current_buffer</a>-&gt;<a class="code" href="structyy__buffer__state.html#o9">yy_buffer_status</a> == <a class="code" href="_dict_scaner_8cpp.html#a19">YY_BUFFER_NEW</a> )
00661                         {
00662                         <span class="comment">/* We're scanning a new file or input source.  It's</span>
00663 <span class="comment">                         * possible that this happened because the user</span>
00664 <span class="comment">                         * just pointed yyin at a new source and called</span>
00665 <span class="comment">                         * yylex().  If so, then we have to assure</span>
00666 <span class="comment">                         * consistency between yy_current_buffer and our</span>
00667 <span class="comment">                         * globals.  Here is the right place to do so, because</span>
00668 <span class="comment">                         * this is the first action (other than possibly a</span>
00669 <span class="comment">                         * back-up) that will match for the new input source.</span>
00670 <span class="comment">                         */</span>
00671                         <a class="code" href="_frame_scaner_8cpp.html#a62">yy_n_chars</a> = <a class="code" href="_frame_scaner_8cpp.html#a60">yy_current_buffer</a>-&gt;<a class="code" href="structyy__buffer__state.html#o4">yy_n_chars</a>;
00672                         <a class="code" href="_frame_scaner_8cpp.html#a60">yy_current_buffer</a>-&gt;<a class="code" href="structyy__buffer__state.html#o0">yy_input_file</a> = <a class="code" href="_dict_scaner_8cpp.html#a59">yyin</a>;
00673                         <a class="code" href="_frame_scaner_8cpp.html#a60">yy_current_buffer</a>-&gt;<a class="code" href="structyy__buffer__state.html#o9">yy_buffer_status</a> = <a class="code" href="_dict_scaner_8cpp.html#a20">YY_BUFFER_NORMAL</a>;
00674                         }
00675 
00676                 <span class="comment">/* Note that here we test for yy_c_buf_p "&lt;=" to the position</span>
00677 <span class="comment">                 * of the first EOB in the buffer, since yy_c_buf_p will</span>
00678 <span class="comment">                 * already have been incremented past the NUL character</span>
00679 <span class="comment">                 * (since all states make transitions on EOB to the</span>
00680 <span class="comment">                 * end-of-buffer state).  Contrast this with the test</span>
00681 <span class="comment">                 * in input().</span>
00682 <span class="comment">                 */</span>
00683                 <span class="keywordflow">if</span> ( yy_c_buf_p &lt;= &amp;yy_current_buffer-&gt;yy_ch_buf[<a class="code" href="_frame_scaner_8cpp.html#a62">yy_n_chars</a>] )
00684                         { <span class="comment">/* This was really a NUL. */</span>
00685                         <a class="code" href="_dict_scaner_8cpp.html#a70">yy_state_type</a> yy_next_state;
00686 
00687                         <a class="code" href="_frame_scaner_8cpp.html#a63">yy_c_buf_p</a> = <a class="code" href="_dict_scaner_8cpp.html#a30">yytext_ptr</a> + yy_amount_of_matched_text;
00688 
00689                         yy_current_state = yy_get_previous_state();
00690 
00691                         <span class="comment">/* Okay, we're now positioned to make the NUL</span>
00692 <span class="comment">                         * transition.  We couldn't have</span>
00693 <span class="comment">                         * yy_get_previous_state() go ahead and do it</span>
00694 <span class="comment">                         * for us because it doesn't know how to deal</span>
00695 <span class="comment">                         * with the possibility of jamming (and we don't</span>
00696 <span class="comment">                         * want to build jamming into it because then it</span>
00697 <span class="comment">                         * will run more slowly).</span>
00698 <span class="comment">                         */</span>
00699 
00700                         yy_next_state = yy_try_NUL_trans( yy_current_state );
00701 
00702                         <a class="code" href="_dict_scaner_8cpp.html#a82">yy_bp</a> = <a class="code" href="_dict_scaner_8cpp.html#a30">yytext_ptr</a> + <a class="code" href="_dict_scaner_8cpp.html#a36">YY_MORE_ADJ</a>;
00703 
00704                         <span class="keywordflow">if</span> ( yy_next_state )
00705                                 {
00706                                 <span class="comment">/* Consume the NUL. */</span>
00707                                 yy_cp = ++<a class="code" href="_frame_scaner_8cpp.html#a63">yy_c_buf_p</a>;
00708                                 yy_current_state = yy_next_state;
00709                                 <span class="keywordflow">goto</span> yy_match;
00710                                 }
00711 
00712                         <span class="keywordflow">else</span>
00713                                 {
00714                                 yy_cp = <a class="code" href="_frame_scaner_8cpp.html#a63">yy_c_buf_p</a>;
00715                                 <span class="keywordflow">goto</span> yy_find_action;
00716                                 }
00717                         }
00718 
00719                 <span class="keywordflow">else</span> <span class="keywordflow">switch</span> ( yy_get_next_buffer() )
00720                         {
00721                         <span class="keywordflow">case</span> <a class="code" href="_dict_scaner_8cpp.html#a15">EOB_ACT_END_OF_FILE</a>:
00722                                 {
00723                                 <a class="code" href="_frame_scaner_8cpp.html#a66">yy_did_buffer_switch_on_eof</a> = 0;
00724 
00725                                 <span class="keywordflow">if</span> ( <a class="code" href="_dict_scaner_8cpp.html#a28">yywrap</a>() )
00726                                         {
00727                                         <span class="comment">/* Note: because we've taken care in</span>
00728 <span class="comment">                                         * yy_get_next_buffer() to have set up</span>
00729 <span class="comment">                                         * yytext, we can now set up</span>
00730 <span class="comment">                                         * yy_c_buf_p so that if some total</span>
00731 <span class="comment">                                         * hoser (like flex itself) wants to</span>
00732 <span class="comment">                                         * call the scanner after we return the</span>
00733 <span class="comment">                                         * YY_NULL, it'll still work - another</span>
00734 <span class="comment">                                         * YY_NULL will get returned.</span>
00735 <span class="comment">                                         */</span>
00736                                         <a class="code" href="_frame_scaner_8cpp.html#a63">yy_c_buf_p</a> = <a class="code" href="_dict_scaner_8cpp.html#a30">yytext_ptr</a> + <a class="code" href="_dict_scaner_8cpp.html#a36">YY_MORE_ADJ</a>;
00737 
00738                                         yy_act = <a class="code" href="_dict_scaner_8cpp.html#a10">YY_STATE_EOF</a>(<a class="code" href="_dict_scaner_8cpp.html#a8">YY_START</a>);
00739                                         <span class="keywordflow">goto</span> do_action;
00740                                         }
00741 
00742                                 <span class="keywordflow">else</span>
00743                                         {
00744                                         <span class="keywordflow">if</span> ( ! <a class="code" href="_frame_scaner_8cpp.html#a66">yy_did_buffer_switch_on_eof</a> )
00745                                                 <a class="code" href="_dict_scaner_8cpp.html#a11">YY_NEW_FILE</a>;
00746                                         }
00747                                 <span class="keywordflow">break</span>;
00748                                 }
00749 
00750                         <span class="keywordflow">case</span> <a class="code" href="_dict_scaner_8cpp.html#a14">EOB_ACT_CONTINUE_SCAN</a>:
00751                                 <a class="code" href="_frame_scaner_8cpp.html#a63">yy_c_buf_p</a> =
00752                                         <a class="code" href="_dict_scaner_8cpp.html#a30">yytext_ptr</a> + yy_amount_of_matched_text;
00753 
00754                                 yy_current_state = yy_get_previous_state();
00755 
00756                                 yy_cp = <a class="code" href="_frame_scaner_8cpp.html#a63">yy_c_buf_p</a>;
00757                                 <a class="code" href="_dict_scaner_8cpp.html#a82">yy_bp</a> = <a class="code" href="_dict_scaner_8cpp.html#a30">yytext_ptr</a> + <a class="code" href="_dict_scaner_8cpp.html#a36">YY_MORE_ADJ</a>;
00758                                 <span class="keywordflow">goto</span> yy_match;
00759 
00760                         <span class="keywordflow">case</span> <a class="code" href="_dict_scaner_8cpp.html#a16">EOB_ACT_LAST_MATCH</a>:
00761                                 <a class="code" href="_frame_scaner_8cpp.html#a63">yy_c_buf_p</a> =
00762                                 &amp;<a class="code" href="_frame_scaner_8cpp.html#a60">yy_current_buffer</a>-&gt;<a class="code" href="structyy__buffer__state.html#o1">yy_ch_buf</a>[<a class="code" href="_frame_scaner_8cpp.html#a62">yy_n_chars</a>];
00763 
00764                                 yy_current_state = yy_get_previous_state();
00765 
00766                                 yy_cp = <a class="code" href="_frame_scaner_8cpp.html#a63">yy_c_buf_p</a>;
00767                                 <a class="code" href="_dict_scaner_8cpp.html#a82">yy_bp</a> = <a class="code" href="_dict_scaner_8cpp.html#a30">yytext_ptr</a> + <a class="code" href="_dict_scaner_8cpp.html#a36">YY_MORE_ADJ</a>;
00768                                 <span class="keywordflow">goto</span> yy_find_action;
00769                         }
00770                 <span class="keywordflow">break</span>;
00771                 }
00772 
00773         <span class="keywordflow">default</span>:
00774                 <a class="code" href="_dict_scaner_8cpp.html#a51">YY_FATAL_ERROR</a>(
00775                         <span class="stringliteral">"fatal flex scanner internal error--no action found"</span> );
00776         } <span class="comment">/* end of action switch */</span>
00777                 } <span class="comment">/* end of scanning one token */</span>
00778         } <span class="comment">/* end of yylex */</span>
00779 
00780 
00781 <span class="comment">/* yy_get_next_buffer - try to read in a new buffer</span>
00782 <span class="comment"> *</span>
00783 <span class="comment"> * Returns a code representing an action:</span>
00784 <span class="comment"> *      EOB_ACT_LAST_MATCH -</span>
00785 <span class="comment"> *      EOB_ACT_CONTINUE_SCAN - continue scanning from current position</span>
00786 <span class="comment"> *      EOB_ACT_END_OF_FILE - end of file</span>
00787 <span class="comment"> */</span>
00788 
00789 <span class="keyword">static</span> <span class="keywordtype">int</span> yy_get_next_buffer()
00790         {
00791         <span class="keyword">register</span> <span class="keywordtype">char</span> *dest = <a class="code" href="_frame_scaner_8cpp.html#a60">yy_current_buffer</a>-&gt;<a class="code" href="structyy__buffer__state.html#o1">yy_ch_buf</a>;
00792         <span class="keyword">register</span> <span class="keywordtype">char</span> *source = <a class="code" href="_dict_scaner_8cpp.html#a30">yytext_ptr</a>;
00793         <span class="keyword">register</span> <span class="keywordtype">int</span> number_to_move, i;
00794         <span class="keywordtype">int</span> ret_val;
00795 
00796         <span class="keywordflow">if</span> ( yy_c_buf_p &gt; &amp;<a class="code" href="_frame_scaner_8cpp.html#a60">yy_current_buffer</a>-&gt;<a class="code" href="structyy__buffer__state.html#o1">yy_ch_buf</a>[yy_n_chars + 1] )
00797                 YY_FATAL_ERROR(
00798                 "fatal flex scanner internal error--end of buffer missed" );
00799 
00800         if ( yy_current_buffer-&gt;yy_fill_buffer == 0 )
00801                 { <span class="comment">/* Don't try to fill the buffer, so this is an EOF. */</span>
00802                 <span class="keywordflow">if</span> ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )
00803                         {
00804                         <span class="comment">/* We matched a single character, the EOB, so</span>
00805 <span class="comment">                         * treat this as a final EOF.</span>
00806 <span class="comment">                         */</span>
00807                         <span class="keywordflow">return</span> <a class="code" href="_dict_scaner_8cpp.html#a15">EOB_ACT_END_OF_FILE</a>;
00808                         }
00809 
00810                 <span class="keywordflow">else</span>
00811                         {
00812                         <span class="comment">/* We matched some text prior to the EOB, first</span>
00813 <span class="comment">                         * process it.</span>
00814 <span class="comment">                         */</span>
00815                         <span class="keywordflow">return</span> <a class="code" href="_dict_scaner_8cpp.html#a16">EOB_ACT_LAST_MATCH</a>;
00816                         }
00817                 }
00818 
00819         <span class="comment">/* Try to read more data. */</span>
00820 
00821         <span class="comment">/* First move last chars to start of buffer. */</span>
00822         number_to_move = (int) (<a class="code" href="_frame_scaner_8cpp.html#a63">yy_c_buf_p</a> - <a class="code" href="_dict_scaner_8cpp.html#a30">yytext_ptr</a>) - 1;
00823 
00824         <span class="keywordflow">for</span> ( i = 0; i &lt; number_to_move; ++i )
00825                 *(dest++) = *(source++);
00826 
00827         <span class="keywordflow">if</span> ( <a class="code" href="_frame_scaner_8cpp.html#a60">yy_current_buffer</a>-&gt;<a class="code" href="structyy__buffer__state.html#o9">yy_buffer_status</a> == YY_BUFFER_EOF_PENDING )
00828                 <span class="comment">/* don't do the read, it's not guaranteed to return an EOF,</span>
00829 <span class="comment">                 * just force an EOF</span>
00830 <span class="comment">                 */</span>
00831                 yy_current_buffer-&gt;yy_n_chars = yy_n_chars = 0;
00832 
00833         else
00834                 {
00835                 <span class="keywordtype">int</span> num_to_read =
00836                         <a class="code" href="_frame_scaner_8cpp.html#a60">yy_current_buffer</a>-&gt;<a class="code" href="structyy__buffer__state.html#o3">yy_buf_size</a> - number_to_move - 1;
00837 
00838                 <span class="keywordflow">while</span> ( num_to_read &lt;= 0 )
00839                         { <span class="comment">/* Not enough room in the buffer - grow it. */</span>
00840 <span class="preprocessor">#ifdef YY_USES_REJECT</span>
00841 <span class="preprocessor"></span>                        <a class="code" href="_dict_scaner_8cpp.html#a51">YY_FATAL_ERROR</a>(
00842 <span class="stringliteral">"input buffer overflow, can't enlarge buffer because scanner uses REJECT"</span> );
00843 <span class="preprocessor">#else</span>
00844 <span class="preprocessor"></span>
00845                         <span class="comment">/* just a shorter name for the current buffer */</span>
00846                         <a class="code" href="_dict_scaner_8cpp.html#a57">YY_BUFFER_STATE</a> b = <a class="code" href="_frame_scaner_8cpp.html#a60">yy_current_buffer</a>;
00847 
00848                         <span class="keywordtype">int</span> yy_c_buf_p_offset =
00849                                 (int) (<a class="code" href="_frame_scaner_8cpp.html#a63">yy_c_buf_p</a> - b-&gt;<a class="code" href="structyy__buffer__state.html#o1">yy_ch_buf</a>);
00850 
00851                         <span class="keywordflow">if</span> ( b-&gt;<a class="code" href="structyy__buffer__state.html#o5">yy_is_our_buffer</a> )
00852                                 {
00853                                 <span class="keywordtype">int</span> new_size = b-&gt;<a class="code" href="structyy__buffer__state.html#o3">yy_buf_size</a> * 2;
00854 
00855                                 <span class="keywordflow">if</span> ( new_size &lt;= 0 )
00856                                         b-&gt;yy_buf_size += b-&gt;yy_buf_size / 8;
00857                                 else
00858                                         b-&gt;yy_buf_size *= 2;
00859 
00860                                 b-&gt;yy_ch_buf = (<span class="keywordtype">char</span> *)
00861                                         <span class="comment">/* Include room in for 2 EOB chars. */</span>
00862                                         yy_flex_realloc( (<span class="keywordtype">void</span> *) b-&gt;yy_ch_buf,
00863                                                          b-&gt;yy_buf_size + 2 );
00864                                 }
00865                         else
00866                                 <span class="comment">/* Can't grow it, we don't own it. */</span>
00867                                 b-&gt;yy_ch_buf = 0;
00868 
00869                         if ( ! b-&gt;yy_ch_buf )
00870                                 YY_FATAL_ERROR(
00871                                 "fatal error - scanner input buffer overflow" );
00872 
00873                         yy_c_buf_p = &amp;b-&gt;yy_ch_buf[yy_c_buf_p_offset];
00874 
00875                         num_to_read = yy_current_buffer-&gt;yy_buf_size -
00876                                                 number_to_move - 1;
00877 #endif
00878                         }
00879 
00880                 if ( num_to_read &gt; YY_READ_BUF_SIZE )
00881                         num_to_read = YY_READ_BUF_SIZE;
00882 
00883                 <span class="comment">/* Read in more data. */</span>
00884                 YY_INPUT( (&amp;yy_current_buffer-&gt;yy_ch_buf[number_to_move]),
00885                         yy_n_chars, num_to_read );
00886 
00887                 yy_current_buffer-&gt;yy_n_chars = yy_n_chars;
00888                 }
00889 
00890         if ( yy_n_chars == 0 )
00891                 {
00892                 <span class="keywordflow">if</span> ( number_to_move == YY_MORE_ADJ )
00893                         {
00894                         ret_val = <a class="code" href="_dict_scaner_8cpp.html#a15">EOB_ACT_END_OF_FILE</a>;
00895                         yyrestart( yyin );
00896                         }
00897 
00898                 <span class="keywordflow">else</span>
00899                         {
00900                         ret_val = <a class="code" href="_dict_scaner_8cpp.html#a16">EOB_ACT_LAST_MATCH</a>;
00901                         <a class="code" href="_frame_scaner_8cpp.html#a60">yy_current_buffer</a>-&gt;<a class="code" href="structyy__buffer__state.html#o9">yy_buffer_status</a> =
00902                                 <a class="code" href="_dict_scaner_8cpp.html#a21">YY_BUFFER_EOF_PENDING</a>;
00903                         }
00904                 }
00905 
00906         <span class="keywordflow">else</span>
00907                 ret_val = <a class="code" href="_dict_scaner_8cpp.html#a14">EOB_ACT_CONTINUE_SCAN</a>;
00908 
00909         <a class="code" href="_frame_scaner_8cpp.html#a62">yy_n_chars</a> += number_to_move;
00910         <a class="code" href="_frame_scaner_8cpp.html#a60">yy_current_buffer</a>-&gt;<a class="code" href="structyy__buffer__state.html#o1">yy_ch_buf</a>[<a class="code" href="_frame_scaner_8cpp.html#a62">yy_n_chars</a>] = <a class="code" href="_dict_scaner_8cpp.html#a12">YY_END_OF_BUFFER_CHAR</a>;
00911         <a class="code" href="_frame_scaner_8cpp.html#a60">yy_current_buffer</a>-&gt;<a class="code" href="structyy__buffer__state.html#o1">yy_ch_buf</a>[<a class="code" href="_frame_scaner_8cpp.html#a62">yy_n_chars</a> + 1] = <a class="code" href="_dict_scaner_8cpp.html#a12">YY_END_OF_BUFFER_CHAR</a>;
00912 
00913         <a class="code" href="_dict_scaner_8cpp.html#a30">yytext_ptr</a> = &amp;<a class="code" href="_frame_scaner_8cpp.html#a60">yy_current_buffer</a>-&gt;<a class="code" href="structyy__buffer__state.html#o1">yy_ch_buf</a>[0];
00914 
00915         <span class="keywordflow">return</span> ret_val;
00916         }
00917 
00918 
00919 <span class="comment">/* yy_get_previous_state - get the state just before the EOB char was reached */</span>
00920 
00921 <span class="keyword">static</span> <a class="code" href="_dict_scaner_8cpp.html#a70">yy_state_type</a> yy_get_previous_state()
00922         {
00923         <span class="keyword">register</span> <a class="code" href="_dict_scaner_8cpp.html#a70">yy_state_type</a> yy_current_state;
00924         <span class="keyword">register</span> <span class="keywordtype">char</span> *yy_cp;
00925 
00926         yy_current_state = <a class="code" href="_frame_scaner_8cpp.html#a65">yy_start</a>;
00927 
00928         <span class="keywordflow">for</span> ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp &lt; yy_c_buf_p; ++yy_cp )
00929                 {
00930                 <span class="keyword">register</span> <a class="code" href="_dict_scaner_8cpp.html#a69">YY_CHAR</a> yy_c = (*yy_cp ? <a class="code" href="_frame_scaner_8cpp.html#a71">yy_ec</a>[<a class="code" href="_dict_scaner_8cpp.html#a6">YY_SC_TO_UI</a>(*yy_cp)] : 1);
00931                 <span class="keywordflow">if</span> ( yy_accept[yy_current_state] )
00932                         {
00933                         <a class="code" href="_frame_scaner_8cpp.html#a77">yy_last_accepting_state</a> = yy_current_state;
00934                         <a class="code" href="_frame_scaner_8cpp.html#a78">yy_last_accepting_cpos</a> = yy_cp;
00935                         }
00936                 <span class="keywordflow">while</span> ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
00937                         {
00938                         yy_current_state = (int) <a class="code" href="_frame_scaner_8cpp.html#a74">yy_def</a>[yy_current_state];
00939                         <span class="keywordflow">if</span> ( yy_current_state &gt;= 14 )
00940                                 yy_c = yy_meta[(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) yy_c];
00941                         }
00942                 yy_current_state = yy_nxt[yy_base[yy_current_state] + (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) yy_c];
00943                 }
00944 
00945         return yy_current_state;
00946         }
00947 
00948 
00949 <span class="comment">/* yy_try_NUL_trans - try to make a transition on the NUL character</span>
00950 <span class="comment"> *</span>
00951 <span class="comment"> * synopsis</span>
00952 <span class="comment"> *      next_state = yy_try_NUL_trans( current_state );</span>
00953 <span class="comment"> */</span>
00954 
00955 #ifdef YY_USE_PROTOS
00956 static yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )
00957 #else
00958 static yy_state_type yy_try_NUL_trans( yy_current_state )
<a name="l00959"></a><a class="code" href="_frame_scaner_8cpp.html#a80">00959</a> yy_state_type yy_current_state;
00960 #endif
00961         {
00962         <span class="keyword">register</span> <span class="keywordtype">int</span> yy_is_jam;
00963         <span class="keyword">register</span> <span class="keywordtype">char</span> *yy_cp = <a class="code" href="_frame_scaner_8cpp.html#a63">yy_c_buf_p</a>;
00964 
00965         <span class="keyword">register</span> <a class="code" href="_dict_scaner_8cpp.html#a69">YY_CHAR</a> yy_c = 1;
00966         <span class="keywordflow">if</span> ( <a class="code" href="_frame_scaner_8cpp.html#a70">yy_accept</a>[yy_current_state] )
00967                 {
00968                 <a class="code" href="_frame_scaner_8cpp.html#a77">yy_last_accepting_state</a> = yy_current_state;
00969                 <a class="code" href="_frame_scaner_8cpp.html#a78">yy_last_accepting_cpos</a> = yy_cp;
00970                 }
00971         <span class="keywordflow">while</span> ( <a class="code" href="_frame_scaner_8cpp.html#a76">yy_chk</a>[<a class="code" href="_frame_scaner_8cpp.html#a73">yy_base</a>[yy_current_state] + yy_c] != yy_current_state )
00972                 {
00973                 yy_current_state = (int) <a class="code" href="_frame_scaner_8cpp.html#a74">yy_def</a>[yy_current_state];
00974                 <span class="keywordflow">if</span> ( yy_current_state &gt;= 14 )
00975                         yy_c = <a class="code" href="_frame_scaner_8cpp.html#a72">yy_meta</a>[(<span class="keywordtype">unsigned</span> int) yy_c];
00976                 }
00977         yy_current_state = <a class="code" href="_frame_scaner_8cpp.html#a75">yy_nxt</a>[<a class="code" href="_frame_scaner_8cpp.html#a73">yy_base</a>[yy_current_state] + (<span class="keywordtype">unsigned</span> int) yy_c];
00978         yy_is_jam = (yy_current_state == 13);
00979 
00980         <span class="keywordflow">return</span> yy_is_jam ? 0 : yy_current_state;
00981         }
00982 
00983 
00984 <span class="preprocessor">#ifndef YY_NO_UNPUT</span>
00985 <span class="preprocessor"></span><span class="preprocessor">#ifdef YY_USE_PROTOS</span>
00986 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> yyunput( <span class="keywordtype">int</span> c, <span class="keyword">register</span> <span class="keywordtype">char</span> *yy_bp )
00987 #<span class="keywordflow">else</span>
00988 <span class="keyword">static</span> <span class="keywordtype">void</span> yyunput( c, yy_bp )
00989 int c;
00990 register <span class="keywordtype">char</span> *yy_bp;
00991 #endif
00992         {
00993         <span class="keyword">register</span> <span class="keywordtype">char</span> *yy_cp = <a class="code" href="_frame_scaner_8cpp.html#a63">yy_c_buf_p</a>;
00994 
00995         <span class="comment">/* undo effects of setting up yytext */</span>
00996         *yy_cp = <a class="code" href="_frame_scaner_8cpp.html#a61">yy_hold_char</a>;
00997 
00998         <span class="keywordflow">if</span> ( yy_cp &lt; yy_current_buffer-&gt;yy_ch_buf + 2 )
00999                 { <span class="comment">/* need to shift things up to make room */</span>
01000                 <span class="comment">/* +2 for EOB chars. */</span>
01001                 <span class="keyword">register</span> <span class="keywordtype">int</span> number_to_move = <a class="code" href="_frame_scaner_8cpp.html#a62">yy_n_chars</a> + 2;
01002                 <span class="keyword">register</span> <span class="keywordtype">char</span> *dest = &amp;<a class="code" href="_frame_scaner_8cpp.html#a60">yy_current_buffer</a>-&gt;<a class="code" href="structyy__buffer__state.html#o1">yy_ch_buf</a>[
01003                                         <a class="code" href="_frame_scaner_8cpp.html#a60">yy_current_buffer</a>-&gt;<a class="code" href="structyy__buffer__state.html#o3">yy_buf_size</a> + 2];
01004                 <span class="keyword">register</span> <span class="keywordtype">char</span> *source =
01005                                 &amp;<a class="code" href="_frame_scaner_8cpp.html#a60">yy_current_buffer</a>-&gt;<a class="code" href="structyy__buffer__state.html#o1">yy_ch_buf</a>[number_to_move];
01006 
01007                 <span class="keywordflow">while</span> ( source &gt; <a class="code" href="_frame_scaner_8cpp.html#a60">yy_current_buffer</a>-&gt;<a class="code" href="structyy__buffer__state.html#o1">yy_ch_buf</a> )
01008                         *--dest = *--source;
01009 
01010                 yy_cp += (int) (dest - source);
01011                 <a class="code" href="_dict_scaner_8cpp.html#a82">yy_bp</a> += (int) (dest - source);
01012                 <a class="code" href="_frame_scaner_8cpp.html#a60">yy_current_buffer</a>-&gt;<a class="code" href="structyy__buffer__state.html#o4">yy_n_chars</a> =
01013                         <a class="code" href="_frame_scaner_8cpp.html#a62">yy_n_chars</a> = <a class="code" href="_frame_scaner_8cpp.html#a60">yy_current_buffer</a>-&gt;<a class="code" href="structyy__buffer__state.html#o3">yy_buf_size</a>;
01014 
01015                 <span class="keywordflow">if</span> ( yy_cp &lt; yy_current_buffer-&gt;yy_ch_buf + 2 )
01016                         YY_FATAL_ERROR( "flex scanner push-back overflow" );
01017                 }
01018 
01019         *--yy_cp = (<span class="keywordtype">char</span>) c;
01020 
01021 
01022         yytext_ptr = yy_bp;
01023         yy_hold_char = *yy_cp;
01024         yy_c_buf_p = yy_cp;
01025         }
01026 #endif  <span class="comment">/* ifndef YY_NO_UNPUT */</span>
01027 
01028 
01029 #ifdef __cplusplus
01030 static <span class="keywordtype">int</span> yyinput()
01031 #else
01032 static <span class="keywordtype">int</span> input()
01033 #endif
01034         {
01035         <span class="keywordtype">int</span> c;
01036 
01037         *<a class="code" href="_frame_scaner_8cpp.html#a63">yy_c_buf_p</a> = <a class="code" href="_frame_scaner_8cpp.html#a61">yy_hold_char</a>;
01038 
01039         <span class="keywordflow">if</span> ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
01040                 {
01041                 <span class="comment">/* yy_c_buf_p now points to the character we want to return.</span>
01042 <span class="comment">                 * If this occurs *before* the EOB characters, then it's a</span>
01043 <span class="comment">                 * valid NUL; if not, then we've hit the end of the buffer.</span>
01044 <span class="comment">                 */</span>
01045                 <span class="keywordflow">if</span> ( yy_c_buf_p &lt; &amp;yy_current_buffer-&gt;yy_ch_buf[yy_n_chars] )
01046                         <span class="comment">/* This was really a NUL. */</span>
01047                         *<a class="code" href="_frame_scaner_8cpp.html#a63">yy_c_buf_p</a> = <span class="charliteral">'\0'</span>;
01048 
01049                 <span class="keywordflow">else</span>
01050                         { <span class="comment">/* need more input */</span>
01051                         <span class="keywordtype">int</span> offset = <a class="code" href="_frame_scaner_8cpp.html#a63">yy_c_buf_p</a> - <a class="code" href="_dict_scaner_8cpp.html#a30">yytext_ptr</a>;
01052                         ++<a class="code" href="_frame_scaner_8cpp.html#a63">yy_c_buf_p</a>;
01053 
01054                         <span class="keywordflow">switch</span> ( yy_get_next_buffer() )
01055                                 {
01056                                 <span class="keywordflow">case</span> <a class="code" href="_dict_scaner_8cpp.html#a16">EOB_ACT_LAST_MATCH</a>:
01057                                         <span class="comment">/* This happens because yy_g_n_b()</span>
01058 <span class="comment">                                         * sees that we've accumulated a</span>
01059 <span class="comment">                                         * token and flags that we need to</span>
01060 <span class="comment">                                         * try matching the token before</span>
01061 <span class="comment">                                         * proceeding.  But for input(),</span>
01062 <span class="comment">                                         * there's no matching to consider.</span>
01063 <span class="comment">                                         * So convert the EOB_ACT_LAST_MATCH</span>
01064 <span class="comment">                                         * to EOB_ACT_END_OF_FILE.</span>
01065 <span class="comment">                                         */</span>
01066 
01067                                         <span class="comment">/* Reset buffer status. */</span>
01068                                         yyrestart( yyin );
01069 
01070                                         <span class="comment">/* fall through */</span>
01071 
01072                                 <span class="keywordflow">case</span> <a class="code" href="_dict_scaner_8cpp.html#a15">EOB_ACT_END_OF_FILE</a>:
01073                                         {
01074                                         <span class="keywordflow">if</span> ( <a class="code" href="_dict_scaner_8cpp.html#a28">yywrap</a>() )
01075                                                 return EOF;
01076 
01077                                         if ( ! yy_did_buffer_switch_on_eof )
01078                                                 YY_NEW_FILE;
01079 #ifdef __cplusplus
01080                                         return yyinput();
01081 #else
01082                                         return input();
01083 #endif
01084                                         }
01085 
01086                                 case EOB_ACT_CONTINUE_SCAN:
01087                                         yy_c_buf_p = yytext_ptr + offset;
01088                                         break;
01089                                 }
01090                         }
01091                 }
01092 
01093         c = *(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) yy_c_buf_p;      <span class="comment">/* cast for 8-bit char's */</span>
01094         *yy_c_buf_p = '\0';     <span class="comment">/* preserve yytext */</span>
01095         yy_hold_char = *++yy_c_buf_p;
01096 
01097 
01098         return c;
01099         }
01100 
01101 
01102 #ifdef YY_USE_PROTOS
01103 <span class="keywordtype">void</span> yyrestart( FILE *input_file )
01104 #else
01105 <span class="keywordtype">void</span> yyrestart( input_file )
01106 FILE *input_file;
01107 #endif
01108         {
01109         <span class="keywordflow">if</span> ( ! yy_current_buffer )
01110                 yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );
01111 
01112         yy_init_buffer( yy_current_buffer, input_file );
01113         yy_load_buffer_state();
01114         }
01115 
01116 
01117 #ifdef YY_USE_PROTOS
01118 <span class="keywordtype">void</span> yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
01119 #else
01120 <span class="keywordtype">void</span> yy_switch_to_buffer( new_buffer )
01121 YY_BUFFER_STATE new_buffer;
01122 #endif
01123         {
01124         <span class="keywordflow">if</span> ( yy_current_buffer == new_buffer )
01125                 return;
01126 
01127         if ( yy_current_buffer )
01128                 {
01129                 <span class="comment">/* Flush out information for old buffer. */</span>
01130                 *<a class="code" href="_frame_scaner_8cpp.html#a63">yy_c_buf_p</a> = <a class="code" href="_frame_scaner_8cpp.html#a61">yy_hold_char</a>;
01131                 <a class="code" href="_frame_scaner_8cpp.html#a60">yy_current_buffer</a>-&gt;<a class="code" href="structyy__buffer__state.html#o2">yy_buf_pos</a> = <a class="code" href="_frame_scaner_8cpp.html#a63">yy_c_buf_p</a>;
01132                 <a class="code" href="_frame_scaner_8cpp.html#a60">yy_current_buffer</a>-&gt;<a class="code" href="structyy__buffer__state.html#o4">yy_n_chars</a> = <a class="code" href="_frame_scaner_8cpp.html#a62">yy_n_chars</a>;
01133                 }
01134 
01135         <a class="code" href="_frame_scaner_8cpp.html#a60">yy_current_buffer</a> = new_buffer;
01136         yy_load_buffer_state();
01137 
01138         <span class="comment">/* We don't actually know whether we did this switch during</span>
01139 <span class="comment">         * EOF (yywrap()) processing, but the only time this flag</span>
01140 <span class="comment">         * is looked at is after yywrap() is called, so it's safe</span>
01141 <span class="comment">         * to go ahead and always set it.</span>
01142 <span class="comment">         */</span>
01143         <a class="code" href="_frame_scaner_8cpp.html#a66">yy_did_buffer_switch_on_eof</a> = 1;
01144         }
01145 
01146 
01147 <span class="preprocessor">#ifdef YY_USE_PROTOS</span>
01148 <span class="preprocessor"></span><span class="keywordtype">void</span> yy_load_buffer_state( <span class="keywordtype">void</span> )
01149 #<span class="keywordflow">else</span>
01150 <span class="keywordtype">void</span> yy_load_buffer_state()
01151 #endif
01152         {
01153         <a class="code" href="_frame_scaner_8cpp.html#a62">yy_n_chars</a> = <a class="code" href="_frame_scaner_8cpp.html#a60">yy_current_buffer</a>-&gt;<a class="code" href="structyy__buffer__state.html#o4">yy_n_chars</a>;
01154         <a class="code" href="_dict_scaner_8cpp.html#a30">yytext_ptr</a> = <a class="code" href="_frame_scaner_8cpp.html#a63">yy_c_buf_p</a> = <a class="code" href="_frame_scaner_8cpp.html#a60">yy_current_buffer</a>-&gt;<a class="code" href="structyy__buffer__state.html#o2">yy_buf_pos</a>;
01155         <a class="code" href="_dict_scaner_8cpp.html#a59">yyin</a> = <a class="code" href="_frame_scaner_8cpp.html#a60">yy_current_buffer</a>-&gt;<a class="code" href="structyy__buffer__state.html#o0">yy_input_file</a>;
01156         <a class="code" href="_frame_scaner_8cpp.html#a61">yy_hold_char</a> = *<a class="code" href="_frame_scaner_8cpp.html#a63">yy_c_buf_p</a>;
01157         }
01158 
01159 
01160 <span class="preprocessor">#ifdef YY_USE_PROTOS</span>
01161 <span class="preprocessor"></span><a class="code" href="_dict_scaner_8cpp.html#a57">YY_BUFFER_STATE</a> yy_create_buffer( FILE *file, <span class="keywordtype">int</span> size )
01162 #<span class="keywordflow">else</span>
01163 <a class="code" href="_dict_scaner_8cpp.html#a57">YY_BUFFER_STATE</a> yy_create_buffer( file, size )
01164 FILE *file;
01165 <span class="keywordtype">int</span> size;
01166 #endif
01167         {
01168         <a class="code" href="_dict_scaner_8cpp.html#a57">YY_BUFFER_STATE</a> b;
01169 
01170         b = (<a class="code" href="_dict_scaner_8cpp.html#a57">YY_BUFFER_STATE</a>) yy_flex_alloc( <span class="keyword">sizeof</span>( <span class="keyword">struct</span> <a class="code" href="structyy__buffer__state.html">yy_buffer_state</a> ) );
01171         <span class="keywordflow">if</span> ( ! b )
01172                 YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
01173 
01174         b-&gt;yy_buf_size = size;
01175 
01176         <span class="comment">/* yy_ch_buf has to be 2 characters longer than the size given because</span>
01177 <span class="comment">         * we need to put in 2 end-of-buffer characters.</span>
01178 <span class="comment">         */</span>
01179         b-&gt;yy_ch_buf = (<span class="keywordtype">char</span> *) yy_flex_alloc( b-&gt;yy_buf_size + 2 );
01180         if ( ! b-&gt;yy_ch_buf )
01181                 YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
01182 
01183         b-&gt;yy_is_our_buffer = 1;
01184 
01185         yy_init_buffer( b, file );
01186 
01187         return b;
01188         }
01189 
01190 
01191 #ifdef YY_USE_PROTOS
01192 <span class="keywordtype">void</span> yy_delete_buffer( YY_BUFFER_STATE b )
01193 #else
01194 <span class="keywordtype">void</span> yy_delete_buffer( b )
<a name="l01195"></a><a class="code" href="_frame_scaner_8cpp.html#a82">01195</a> YY_BUFFER_STATE b;
01196 #endif
01197         {
01198         <span class="keywordflow">if</span> ( ! b )
01199                 <span class="keywordflow">return</span>;
01200 
01201         <span class="keywordflow">if</span> ( b == <a class="code" href="_frame_scaner_8cpp.html#a60">yy_current_buffer</a> )
01202                 <a class="code" href="_frame_scaner_8cpp.html#a60">yy_current_buffer</a> = (<a class="code" href="_dict_scaner_8cpp.html#a57">YY_BUFFER_STATE</a>) 0;
01203 
01204         <span class="keywordflow">if</span> ( b-&gt;yy_is_our_buffer )
01205                 yy_flex_free( (<span class="keywordtype">void</span> *) b-&gt;yy_ch_buf );
01206 
01207         yy_flex_free( (<span class="keywordtype">void</span> *) b );
01208         }
01209 
01210 
01211 <span class="preprocessor">#ifndef YY_ALWAYS_INTERACTIVE</span>
01212 <span class="preprocessor"></span><span class="preprocessor">#ifndef YY_NEVER_INTERACTIVE</span>
01213 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="keywordtype">int</span> isatty <a class="code" href="_dict_scaner_8cpp.html#a4">YY_PROTO</a>(( <span class="keywordtype">int</span> ));
01214 <span class="preprocessor">#endif</span>
01215 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
01216 <span class="preprocessor"></span>
01217 <span class="preprocessor">#ifdef YY_USE_PROTOS</span>
01218 <span class="preprocessor"></span><span class="keywordtype">void</span> yy_init_buffer( YY_BUFFER_STATE b, FILE *file )
01219 #<span class="keywordflow">else</span>
01220 <span class="keywordtype">void</span> yy_init_buffer( b, file )
01221 YY_BUFFER_STATE b;
01222 FILE *file;
01223 #endif
01224 
01225 
01226         {
01227         yy_flush_buffer( b );
01228 
01229         b-&gt;<a class="code" href="structyy__buffer__state.html#o0">yy_input_file</a> = <a class="code" href="_dict_scaner_8cpp.html#a84">file</a>;
01230         b-&gt;<a class="code" href="structyy__buffer__state.html#o8">yy_fill_buffer</a> = 1;
01231 
01232 <span class="preprocessor">#if YY_ALWAYS_INTERACTIVE</span>
01233 <span class="preprocessor"></span>        b-&gt;<a class="code" href="structyy__buffer__state.html#o6">yy_is_interactive</a> = 1;
01234 <span class="preprocessor">#else</span>
01235 <span class="preprocessor"></span><span class="preprocessor">#if YY_NEVER_INTERACTIVE</span>
01236 <span class="preprocessor"></span>        b-&gt;<a class="code" href="structyy__buffer__state.html#o6">yy_is_interactive</a> = 0;
01237 <span class="preprocessor">#else</span>
01238 <span class="preprocessor"></span>        b-&gt;<a class="code" href="structyy__buffer__state.html#o6">yy_is_interactive</a> = <a class="code" href="_dict_scaner_8cpp.html#a84">file</a> ? (isatty( fileno(file) ) &gt; 0) : 0;
01239 <span class="preprocessor">#endif</span>
01240 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
01241 <span class="preprocessor"></span>        }
01242 
01243 
01244 <span class="preprocessor">#ifdef YY_USE_PROTOS</span>
01245 <span class="preprocessor"></span><span class="keywordtype">void</span> yy_flush_buffer( YY_BUFFER_STATE b )
01246 #<span class="keywordflow">else</span>
01247 <span class="keywordtype">void</span> yy_flush_buffer( b )
01248 YY_BUFFER_STATE b;
01249 #endif
01250 
01251         {
01252         <span class="keywordflow">if</span> ( ! b )
01253                 return;
01254 
01255         b-&gt;yy_n_chars = 0;
01256 
01257         <span class="comment">/* We always need two end-of-buffer characters.  The first causes</span>
01258 <span class="comment">         * a transition to the end-of-buffer state.  The second causes</span>
01259 <span class="comment">         * a jam in that state.</span>
01260 <span class="comment">         */</span>
01261         b-&gt;yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
01262         b-&gt;yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
01263 
01264         b-&gt;yy_buf_pos = &amp;b-&gt;yy_ch_buf[0];
01265 
01266         b-&gt;yy_at_bol = 1;
01267         b-&gt;yy_buffer_status = YY_BUFFER_NEW;
01268 
01269         if ( b == yy_current_buffer )
01270                 yy_load_buffer_state();
01271         }
01272 
01273 
01274 #ifndef YY_NO_SCAN_BUFFER
01275 #ifdef YY_USE_PROTOS
01276 YY_BUFFER_STATE yy_scan_buffer( <span class="keywordtype">char</span> *base, yy_size_t size )
01277 #else
01278 YY_BUFFER_STATE yy_scan_buffer( base, size )
01279 <span class="keywordtype">char</span> *base;
01280 yy_size_t size;
01281 #endif
01282         {
01283         <a class="code" href="_dict_scaner_8cpp.html#a57">YY_BUFFER_STATE</a> b;
01284 
01285         <span class="keywordflow">if</span> ( size &lt; 2 ||
01286              base[size-2] != YY_END_OF_BUFFER_CHAR ||
01287              base[size-1] != YY_END_OF_BUFFER_CHAR )
01288                 <span class="comment">/* They forgot to leave room for the EOB's. */</span>
01289                 return 0;
01290 
01291         b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct <a class="code" href="structyy__buffer__state.html">yy_buffer_state</a> ) );
01292         if ( ! b )
01293                 YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
01294 
01295         b-&gt;yy_buf_size = size - 2;      <span class="comment">/* "- 2" to take care of EOB's */</span>
01296         b-&gt;yy_buf_pos = b-&gt;yy_ch_buf = base;
01297         b-&gt;yy_is_our_buffer = 0;
01298         b-&gt;yy_input_file = 0;
01299         b-&gt;yy_n_chars = b-&gt;yy_buf_size;
01300         b-&gt;yy_is_interactive = 0;
01301         b-&gt;yy_at_bol = 1;
01302         b-&gt;yy_fill_buffer = 0;
01303         b-&gt;yy_buffer_status = YY_BUFFER_NEW;
01304 
01305         yy_switch_to_buffer( b );
01306 
01307         return b;
01308         }
01309 #endif
01310 
01311 
01312 #ifndef YY_NO_SCAN_STRING
01313 #ifdef YY_USE_PROTOS
01314 YY_BUFFER_STATE yy_scan_string( yyconst <span class="keywordtype">char</span> *yy_str )
01315 #else
01316 YY_BUFFER_STATE yy_scan_string( yy_str )
<a name="l01317"></a><a class="code" href="_frame_scaner_8cpp.html#a83">01317</a> yyconst <span class="keywordtype">char</span> *yy_str;
01318 #endif
01319         {
01320         <span class="keywordtype">int</span> <a class="code" href="_dict_scaner_8cpp.html#a85">len</a>;
01321         <span class="keywordflow">for</span> ( <a class="code" href="_dict_scaner_8cpp.html#a85">len</a> = 0; yy_str[<a class="code" href="_dict_scaner_8cpp.html#a85">len</a>]; ++<a class="code" href="_dict_scaner_8cpp.html#a85">len</a> )
01322                 ;
01323 
01324         <span class="keywordflow">return</span> yy_scan_bytes( yy_str, <a class="code" href="_dict_scaner_8cpp.html#a85">len</a> );
01325         }
01326 <span class="preprocessor">#endif</span>
01327 <span class="preprocessor"></span>
01328 
01329 <span class="preprocessor">#ifndef YY_NO_SCAN_BYTES</span>
01330 <span class="preprocessor"></span><span class="preprocessor">#ifdef YY_USE_PROTOS</span>
01331 <span class="preprocessor"></span><a class="code" href="_dict_scaner_8cpp.html#a57">YY_BUFFER_STATE</a> yy_scan_bytes( yyconst <span class="keywordtype">char</span> *bytes, <span class="keywordtype">int</span> len )
01332 #<span class="keywordflow">else</span>
01333 <a class="code" href="_dict_scaner_8cpp.html#a57">YY_BUFFER_STATE</a> yy_scan_bytes( bytes, len )
01334 yyconst <span class="keywordtype">char</span> *bytes;
01335 <span class="keywordtype">int</span> len;
01336 #endif
01337         {
01338         <a class="code" href="_dict_scaner_8cpp.html#a57">YY_BUFFER_STATE</a> b;
01339         <span class="keywordtype">char</span> *buf;
01340         <a class="code" href="_dict_scaner_8cpp.html#a61">yy_size_t</a> n;
01341         <span class="keywordtype">int</span> i;
01342 
01343         <span class="comment">/* Get memory for full buffer, including space for trailing EOB's. */</span>
01344         n = <a class="code" href="_dict_scaner_8cpp.html#a85">len</a> + 2;
01345         buf = (<span class="keywordtype">char</span> *) yy_flex_alloc( n );
01346         <span class="keywordflow">if</span> ( ! buf )
01347                 YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
01348 
01349         for ( i = 0; i &lt; len; ++i )
01350                 buf[i] = bytes[i];
01351 
01352         buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;
01353 
01354         b = yy_scan_buffer( buf, n );
01355         if ( ! b )
01356                 YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
01357 
01358         <span class="comment">/* It's okay to grow etc. this buffer, and we should throw it</span>
01359 <span class="comment">         * away when we're done.</span>
01360 <span class="comment">         */</span>
01361         b-&gt;yy_is_our_buffer = 1;
01362 
01363         return b;
01364         }
01365 #endif
01366 
01367 
01368 #ifndef YY_NO_PUSH_STATE
01369 #ifdef YY_USE_PROTOS
01370 static <span class="keywordtype">void</span> yy_push_state( <span class="keywordtype">int</span> new_state )
01371 #else
01372 static <span class="keywordtype">void</span> yy_push_state( new_state )
01373 <span class="keywordtype">int</span> new_state;
01374 #endif
01375         {
01376         <span class="keywordflow">if</span> ( yy_start_stack_ptr &gt;= yy_start_stack_depth )
01377                 {
01378                 <a class="code" href="_dict_scaner_8cpp.html#a61">yy_size_t</a> new_size;
01379 
01380                 yy_start_stack_depth += <a class="code" href="_dict_scaner_8cpp.html#a50">YY_START_STACK_INCR</a>;
01381                 new_size = yy_start_stack_depth * <span class="keyword">sizeof</span>( int );
01382 
01383                 <span class="keywordflow">if</span> ( ! yy_start_stack )
01384                         yy_start_stack = (<span class="keywordtype">int</span> *) yy_flex_alloc( new_size );
01385 
01386                 else
01387                         yy_start_stack = (<span class="keywordtype">int</span> *) yy_flex_realloc(
01388                                         (<span class="keywordtype">void</span> *) yy_start_stack, new_size );
01389 
01390                 if ( ! yy_start_stack )
01391                         YY_FATAL_ERROR(
01392                         "out of memory expanding start-condition stack" );
01393                 }
01394 
01395         yy_start_stack[yy_start_stack_ptr++] = YY_START;
01396 
01397         BEGIN(new_state);
01398         }
01399 #endif
01400 
01401 
01402 #ifndef YY_NO_POP_STATE
01403 static <span class="keywordtype">void</span> yy_pop_state()
01404         {
01405         <span class="keywordflow">if</span> ( --yy_start_stack_ptr &lt; 0 )
01406                 YY_FATAL_ERROR( "start-condition stack underflow" );
01407 
01408         BEGIN(yy_start_stack[yy_start_stack_ptr]);
01409         }
01410 #endif
01411 
01412 
01413 #ifndef YY_NO_TOP_STATE
01414 static <span class="keywordtype">int</span> yy_top_state()
01415         {
01416         <span class="keywordflow">return</span> yy_start_stack[yy_start_stack_ptr - 1];
01417         }
01418 <span class="preprocessor">#endif</span>
01419 <span class="preprocessor"></span>
01420 <span class="preprocessor">#ifndef YY_EXIT_FAILURE</span>
01421 <span class="preprocessor"></span><span class="preprocessor">#define YY_EXIT_FAILURE 2</span>
01422 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
01423 <span class="preprocessor"></span>
01424 <span class="preprocessor">#ifdef YY_USE_PROTOS</span>
01425 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> yy_fatal_error( yyconst <span class="keywordtype">char</span> msg[] )
01426 #<span class="keywordflow">else</span>
01427 <span class="keyword">static</span> <span class="keywordtype">void</span> yy_fatal_error( msg )
<a name="l01428"></a><a class="code" href="_frame_scaner_8cpp.html#a81">01428</a> char msg[];
01429 #endif
01430         {
01431         (void) fprintf( stderr, <span class="stringliteral">"%s\n"</span>, msg );
01432         exit( <a class="code" href="_dict_scaner_8cpp.html#a55">YY_EXIT_FAILURE</a> );
01433         }
01434 
01435 
01436 
01437 <span class="comment">/* Redefine yyless() so it works in section 3 code. */</span>
01438 
01439 <span class="preprocessor">#undef yyless</span>
01440 <span class="preprocessor"></span><span class="preprocessor">#define yyless(n) \</span>
01441 <span class="preprocessor">        do \</span>
01442 <span class="preprocessor">                { \</span>
01443 <span class="preprocessor">                </span><span class="comment">/* Undo effects of setting up yytext. */</span> \
01444                 yytext[yyleng] = yy_hold_char; \
01445                 yy_c_buf_p = yytext + n; \
01446                 yy_hold_char = *yy_c_buf_p; \
01447                 *yy_c_buf_p = '\0'; \
01448                 yyleng = n; \
01449                 } \
01450         while ( 0 )
01451 
01452 
01453 <span class="comment">/* Internal utility routines. */</span>
01454 
01455 <span class="preprocessor">#ifndef yytext_ptr</span>
01456 <span class="preprocessor"></span><span class="preprocessor">#ifdef YY_USE_PROTOS</span>
01457 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> yy_flex_strncpy( <span class="keywordtype">char</span> *s1, yyconst <span class="keywordtype">char</span> *s2, <span class="keywordtype">int</span> n )
01458 #<span class="keywordflow">else</span>
01459 <span class="keyword">static</span> <span class="keywordtype">void</span> yy_flex_strncpy( s1, s2, n )
01460 char *s1;
01461 yyconst <span class="keywordtype">char</span> *s2;
01462 <span class="keywordtype">int</span> n;
01463 #endif
01464         {
01465         <span class="keyword">register</span> <span class="keywordtype">int</span> i;
01466         <span class="keywordflow">for</span> ( i = 0; i &lt; n; ++i )
01467                 s1[i] = s2[i];
01468         }
01469 #endif
01470 
01471 #ifdef YY_NEED_STRLEN
01472 #ifdef YY_USE_PROTOS
01473 static <span class="keywordtype">int</span> yy_flex_strlen( yyconst <span class="keywordtype">char</span> *s )
01474 #else
01475 static <span class="keywordtype">int</span> yy_flex_strlen( s )
01476 yyconst <span class="keywordtype">char</span> *s;
01477 #endif
01478         {
01479         <span class="keyword">register</span> <span class="keywordtype">int</span> n;
01480         <span class="keywordflow">for</span> ( n = 0; s[n]; ++n )
01481                 ;
01482 
01483         <span class="keywordflow">return</span> n;
01484         }
01485 <span class="preprocessor">#endif</span>
01486 <span class="preprocessor"></span>
01487 
01488 <span class="preprocessor">#ifdef YY_USE_PROTOS</span>
01489 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> *yy_flex_alloc( yy_size_t size )
01490 #<span class="keywordflow">else</span>
01491 <span class="keyword">static</span> <span class="keywordtype">void</span> *yy_flex_alloc( size )
01492 yy_size_t size;
01493 #endif
01494         {
01495         <span class="keywordflow">return</span> (<span class="keywordtype">void</span> *) malloc( size );
01496         }
01497 
01498 #ifdef YY_USE_PROTOS
01499 static <span class="keywordtype">void</span> *yy_flex_realloc( <span class="keywordtype">void</span> *ptr, yy_size_t size )
01500 #else
01501 static <span class="keywordtype">void</span> *yy_flex_realloc( ptr, size )
01502 <span class="keywordtype">void</span> *ptr;
01503 yy_size_t size;
01504 #endif
01505         {
01506         <span class="comment">/* The cast to (char *) in the following accommodates both</span>
01507 <span class="comment">         * implementations that use char* generic pointers, and those</span>
01508 <span class="comment">         * that use void* generic pointers.  It works with the latter</span>
01509 <span class="comment">         * because both ANSI C and C++ allow castless assignment from</span>
01510 <span class="comment">         * any pointer type to void*, and deal with argument conversions</span>
01511 <span class="comment">         * as though doing an assignment.</span>
01512 <span class="comment">         */</span>
01513         <span class="keywordflow">return</span> (<span class="keywordtype">void</span> *) realloc( (<span class="keywordtype">char</span> *) ptr, size );
01514         }
01515 
01516 #ifdef YY_USE_PROTOS
01517 static <span class="keywordtype">void</span> yy_flex_free( <span class="keywordtype">void</span> *ptr )
01518 #else
01519 static <span class="keywordtype">void</span> yy_flex_free( ptr )
01520 <span class="keywordtype">void</span> *ptr;
01521 #endif
01522         {
01523         free( ptr );
01524         }
01525 
01526 <span class="preprocessor">#if YY_MAIN</span>
01527 <span class="preprocessor"></span><span class="keywordtype">int</span> main()
01528         {
01529         <a class="code" href="_dict_parser_8cpp.html#a83">yylex</a>();
01530         <span class="keywordflow">return</span> 0;
01531         }
01532 <span class="preprocessor">#endif</span>
01533 <span class="preprocessor"></span><span class="preprocessor">#line 23 "FrameScaner.l"</span>
01534 <span class="preprocessor"></span>
01535 <span class="keywordtype">int</span> <a class="code" href="_frame_scaner_8l.html#a5">a</a> = 1;
01536 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Jan 12 11:24:53 2005 for compiler by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.1 </small></address>
</body>
</html>
